/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/clipboard";
exports.ids = ["vendor-chunks/clipboard"];
exports.modules = {

/***/ "(ssr)/./node_modules/clipboard/dist/clipboard.js":
/*!**************************************************!*\
  !*** ./node_modules/clipboard/dist/clipboard.js ***!
  \**************************************************/
/***/ (function(module) {

eval("/*!\n * clipboard.js v2.0.11\n * https://clipboardjs.com/\n *\n * Licensed MIT Â© Zeno Rocha\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(this, function() {\n    return /******/ function() {\n        /******/ var __webpack_modules__ = {\n            /***/ 686: /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_629__) {\n                \"use strict\";\n                // EXPORTS\n                __nested_webpack_require_629__.d(__nested_webpack_exports__, {\n                    \"default\": function() {\n                        return /* binding */ clipboard;\n                    }\n                });\n                // EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js\n                var tiny_emitter = __nested_webpack_require_629__(279);\n                var tiny_emitter_default = /*#__PURE__*/ __nested_webpack_require_629__.n(tiny_emitter);\n                // EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js\n                var listen = __nested_webpack_require_629__(370);\n                var listen_default = /*#__PURE__*/ __nested_webpack_require_629__.n(listen);\n                // EXTERNAL MODULE: ./node_modules/select/src/select.js\n                var src_select = __nested_webpack_require_629__(817);\n                var select_default = /*#__PURE__*/ __nested_webpack_require_629__.n(src_select);\n                ; // CONCATENATED MODULE: ./src/common/command.js\n                /**\n * Executes a given operation type.\n * @param {String} type\n * @return {Boolean}\n */ function command(type) {\n                    try {\n                        return document.execCommand(type);\n                    } catch (err) {\n                        return false;\n                    }\n                }\n                ; // CONCATENATED MODULE: ./src/actions/cut.js\n                /**\n * Cut action wrapper.\n * @param {String|HTMLElement} target\n * @return {String}\n */ var ClipboardActionCut = function ClipboardActionCut(target) {\n                    var selectedText = select_default()(target);\n                    command(\"cut\");\n                    return selectedText;\n                };\n                /* harmony default export */ var actions_cut = ClipboardActionCut;\n                ; // CONCATENATED MODULE: ./src/common/create-fake-element.js\n                /**\n * Creates a fake textarea element with a value.\n * @param {String} value\n * @return {HTMLElement}\n */ function createFakeElement(value) {\n                    var isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n                    var fakeElement = document.createElement(\"textarea\"); // Prevent zooming on iOS\n                    fakeElement.style.fontSize = \"12pt\"; // Reset box model\n                    fakeElement.style.border = \"0\";\n                    fakeElement.style.padding = \"0\";\n                    fakeElement.style.margin = \"0\"; // Move element out of screen horizontally\n                    fakeElement.style.position = \"absolute\";\n                    fakeElement.style[isRTL ? \"right\" : \"left\"] = \"-9999px\"; // Move element to the same position vertically\n                    var yPosition = window.pageYOffset || document.documentElement.scrollTop;\n                    fakeElement.style.top = \"\".concat(yPosition, \"px\");\n                    fakeElement.setAttribute(\"readonly\", \"\");\n                    fakeElement.value = value;\n                    return fakeElement;\n                }\n                ; // CONCATENATED MODULE: ./src/actions/copy.js\n                /**\n * Create fake copy action wrapper using a fake element.\n * @param {String} target\n * @param {Object} options\n * @return {String}\n */ var fakeCopyAction = function fakeCopyAction(value, options) {\n                    var fakeElement = createFakeElement(value);\n                    options.container.appendChild(fakeElement);\n                    var selectedText = select_default()(fakeElement);\n                    command(\"copy\");\n                    fakeElement.remove();\n                    return selectedText;\n                };\n                /**\n * Copy action wrapper.\n * @param {String|HTMLElement} target\n * @param {Object} options\n * @return {String}\n */ var ClipboardActionCopy = function ClipboardActionCopy(target) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n                        container: document.body\n                    };\n                    var selectedText = \"\";\n                    if (typeof target === \"string\") {\n                        selectedText = fakeCopyAction(target, options);\n                    } else if (target instanceof HTMLInputElement && ![\n                        \"text\",\n                        \"search\",\n                        \"url\",\n                        \"tel\",\n                        \"password\"\n                    ].includes(target === null || target === void 0 ? void 0 : target.type)) {\n                        // If input type doesn't support `setSelectionRange`. Simulate it. https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange\n                        selectedText = fakeCopyAction(target.value, options);\n                    } else {\n                        selectedText = select_default()(target);\n                        command(\"copy\");\n                    }\n                    return selectedText;\n                };\n                /* harmony default export */ var actions_copy = ClipboardActionCopy;\n                ; // CONCATENATED MODULE: ./src/actions/default.js\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        _typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        _typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return _typeof(obj);\n                }\n                /**\n * Inner function which performs selection from either `text` or `target`\n * properties and then executes copy or cut operations.\n * @param {Object} options\n */ var ClipboardActionDefault = function ClipboardActionDefault() {\n                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                    // Defines base properties passed from constructor.\n                    var _options$action = options.action, action = _options$action === void 0 ? \"copy\" : _options$action, container = options.container, target = options.target, text = options.text; // Sets the `action` to be performed which can be either 'copy' or 'cut'.\n                    if (action !== \"copy\" && action !== \"cut\") {\n                        throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n                    } // Sets the `target` property using an element that will be have its content copied.\n                    if (target !== undefined) {\n                        if (target && _typeof(target) === \"object\" && target.nodeType === 1) {\n                            if (action === \"copy\" && target.hasAttribute(\"disabled\")) {\n                                throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                            }\n                            if (action === \"cut\" && (target.hasAttribute(\"readonly\") || target.hasAttribute(\"disabled\"))) {\n                                throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                            }\n                        } else {\n                            throw new Error('Invalid \"target\" value, use a valid Element');\n                        }\n                    } // Define selection strategy based on `text` property.\n                    if (text) {\n                        return actions_copy(text, {\n                            container: container\n                        });\n                    } // Defines which selection strategy based on `target` property.\n                    if (target) {\n                        return action === \"cut\" ? actions_cut(target) : actions_copy(target, {\n                            container: container\n                        });\n                    }\n                };\n                /* harmony default export */ var actions_default = ClipboardActionDefault;\n                ; // CONCATENATED MODULE: ./src/clipboard.js\n                function clipboard_typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        clipboard_typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        clipboard_typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return clipboard_typeof(obj);\n                }\n                function _classCallCheck(instance, Constructor) {\n                    if (!(instance instanceof Constructor)) {\n                        throw new TypeError(\"Cannot call a class as a function\");\n                    }\n                }\n                function _defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                function _createClass(Constructor, protoProps, staticProps) {\n                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) _defineProperties(Constructor, staticProps);\n                    return Constructor;\n                }\n                function _inherits(subClass, superClass) {\n                    if (typeof superClass !== \"function\" && superClass !== null) {\n                        throw new TypeError(\"Super expression must either be null or a function\");\n                    }\n                    subClass.prototype = Object.create(superClass && superClass.prototype, {\n                        constructor: {\n                            value: subClass,\n                            writable: true,\n                            configurable: true\n                        }\n                    });\n                    if (superClass) _setPrototypeOf(subClass, superClass);\n                }\n                function _setPrototypeOf(o, p) {\n                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n                        o.__proto__ = p;\n                        return o;\n                    };\n                    return _setPrototypeOf(o, p);\n                }\n                function _createSuper(Derived) {\n                    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n                    return function _createSuperInternal() {\n                        var Super = _getPrototypeOf(Derived), result;\n                        if (hasNativeReflectConstruct) {\n                            var NewTarget = _getPrototypeOf(this).constructor;\n                            result = Reflect.construct(Super, arguments, NewTarget);\n                        } else {\n                            result = Super.apply(this, arguments);\n                        }\n                        return _possibleConstructorReturn(this, result);\n                    };\n                }\n                function _possibleConstructorReturn(self, call) {\n                    if (call && (clipboard_typeof(call) === \"object\" || typeof call === \"function\")) {\n                        return call;\n                    }\n                    return _assertThisInitialized(self);\n                }\n                function _assertThisInitialized(self) {\n                    if (self === void 0) {\n                        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                    }\n                    return self;\n                }\n                function _isNativeReflectConstruct() {\n                    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n                    if (Reflect.construct.sham) return false;\n                    if (typeof Proxy === \"function\") return true;\n                    try {\n                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n                        return true;\n                    } catch (e) {\n                        return false;\n                    }\n                }\n                function _getPrototypeOf(o) {\n                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n                        return o.__proto__ || Object.getPrototypeOf(o);\n                    };\n                    return _getPrototypeOf(o);\n                }\n                /**\n * Helper function to retrieve attribute value.\n * @param {String} suffix\n * @param {Element} element\n */ function getAttributeValue(suffix, element) {\n                    var attribute = \"data-clipboard-\".concat(suffix);\n                    if (!element.hasAttribute(attribute)) {\n                        return;\n                    }\n                    return element.getAttribute(attribute);\n                }\n                /**\n * Base class which takes one or more elements, adds event listeners to them,\n * and instantiates a new `ClipboardAction` on each click.\n */ var Clipboard = /*#__PURE__*/ function(_Emitter) {\n                    _inherits(Clipboard, _Emitter);\n                    var _super = _createSuper(Clipboard);\n                    /**\n   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n   * @param {Object} options\n   */ function Clipboard(trigger, options) {\n                        var _this;\n                        _classCallCheck(this, Clipboard);\n                        _this = _super.call(this);\n                        _this.resolveOptions(options);\n                        _this.listenClick(trigger);\n                        return _this;\n                    }\n                    /**\n   * Defines if attributes would be resolved using internal setter functions\n   * or custom functions that were passed in the constructor.\n   * @param {Object} options\n   */ _createClass(Clipboard, [\n                        {\n                            key: \"resolveOptions\",\n                            value: function resolveOptions() {\n                                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                                this.action = typeof options.action === \"function\" ? options.action : this.defaultAction;\n                                this.target = typeof options.target === \"function\" ? options.target : this.defaultTarget;\n                                this.text = typeof options.text === \"function\" ? options.text : this.defaultText;\n                                this.container = clipboard_typeof(options.container) === \"object\" ? options.container : document.body;\n                            }\n                        },\n                        {\n                            key: \"listenClick\",\n                            value: function listenClick(trigger) {\n                                var _this2 = this;\n                                this.listener = listen_default()(trigger, \"click\", function(e) {\n                                    return _this2.onClick(e);\n                                });\n                            }\n                        },\n                        {\n                            key: \"onClick\",\n                            value: function onClick(e) {\n                                var trigger = e.delegateTarget || e.currentTarget;\n                                var action = this.action(trigger) || \"copy\";\n                                var text = actions_default({\n                                    action: action,\n                                    container: this.container,\n                                    target: this.target(trigger),\n                                    text: this.text(trigger)\n                                }); // Fires an event based on the copy operation result.\n                                this.emit(text ? \"success\" : \"error\", {\n                                    action: action,\n                                    text: text,\n                                    trigger: trigger,\n                                    clearSelection: function clearSelection() {\n                                        if (trigger) {\n                                            trigger.focus();\n                                        }\n                                        window.getSelection().removeAllRanges();\n                                    }\n                                });\n                            }\n                        },\n                        {\n                            key: \"defaultAction\",\n                            value: function defaultAction(trigger) {\n                                return getAttributeValue(\"action\", trigger);\n                            }\n                        },\n                        {\n                            key: \"defaultTarget\",\n                            value: function defaultTarget(trigger) {\n                                var selector = getAttributeValue(\"target\", trigger);\n                                if (selector) {\n                                    return document.querySelector(selector);\n                                }\n                            }\n                        },\n                        {\n                            key: \"defaultText\",\n                            /**\n     * Default `text` lookup function.\n     * @param {Element} trigger\n     */ value: function defaultText(trigger) {\n                                return getAttributeValue(\"text\", trigger);\n                            }\n                        },\n                        {\n                            key: \"destroy\",\n                            value: function destroy() {\n                                this.listener.destroy();\n                            }\n                        }\n                    ], [\n                        {\n                            key: \"copy\",\n                            value: function copy(target) {\n                                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n                                    container: document.body\n                                };\n                                return actions_copy(target, options);\n                            }\n                        },\n                        {\n                            key: \"cut\",\n                            value: function cut(target) {\n                                return actions_cut(target);\n                            }\n                        },\n                        {\n                            key: \"isSupported\",\n                            value: function isSupported() {\n                                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [\n                                    \"copy\",\n                                    \"cut\"\n                                ];\n                                var actions = typeof action === \"string\" ? [\n                                    action\n                                ] : action;\n                                var support = !!document.queryCommandSupported;\n                                actions.forEach(function(action) {\n                                    support = support && !!document.queryCommandSupported(action);\n                                });\n                                return support;\n                            }\n                        }\n                    ]);\n                    return Clipboard;\n                }(tiny_emitter_default());\n                /* harmony default export */ var clipboard = Clipboard;\n            /***/ },\n            /***/ 828: /***/ function(module1) {\n                var DOCUMENT_NODE_TYPE = 9;\n                /**\n * A polyfill for Element.matches()\n */ if (typeof Element !== \"undefined\" && !Element.prototype.matches) {\n                    var proto = Element.prototype;\n                    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;\n                }\n                /**\n * Finds the closest parent that matches a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @return {Function}\n */ function closest(element, selector) {\n                    while(element && element.nodeType !== DOCUMENT_NODE_TYPE){\n                        if (typeof element.matches === \"function\" && element.matches(selector)) {\n                            return element;\n                        }\n                        element = element.parentNode;\n                    }\n                }\n                module1.exports = closest;\n            /***/ },\n            /***/ 438: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_22275__) {\n                var closest = __nested_webpack_require_22275__(828);\n                /**\n * Delegates event to a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */ function _delegate(element, selector, type, callback, useCapture) {\n                    var listenerFn = listener.apply(this, arguments);\n                    element.addEventListener(type, listenerFn, useCapture);\n                    return {\n                        destroy: function() {\n                            element.removeEventListener(type, listenerFn, useCapture);\n                        }\n                    };\n                }\n                /**\n * Delegates event to a selector.\n *\n * @param {Element|String|Array} [elements]\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */ function delegate(elements, selector, type, callback, useCapture) {\n                    // Handle the regular Element usage\n                    if (typeof elements.addEventListener === \"function\") {\n                        return _delegate.apply(null, arguments);\n                    }\n                    // Handle Element-less usage, it defaults to global delegation\n                    if (typeof type === \"function\") {\n                        // Use `document` as the first parameter, then apply arguments\n                        // This is a short way to .unshift `arguments` without running into deoptimizations\n                        return _delegate.bind(null, document).apply(null, arguments);\n                    }\n                    // Handle Selector-based usage\n                    if (typeof elements === \"string\") {\n                        elements = document.querySelectorAll(elements);\n                    }\n                    // Handle Array-like based usage\n                    return Array.prototype.map.call(elements, function(element) {\n                        return _delegate(element, selector, type, callback, useCapture);\n                    });\n                }\n                /**\n * Finds closest match and invokes callback.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Function}\n */ function listener(element, selector, type, callback) {\n                    return function(e) {\n                        e.delegateTarget = closest(e.target, selector);\n                        if (e.delegateTarget) {\n                            callback.call(element, e);\n                        }\n                    };\n                }\n                module1.exports = delegate;\n            /***/ },\n            /***/ 879: /***/ function(__unused_webpack_module, exports1) {\n                /**\n * Check if argument is a HTML element.\n *\n * @param {Object} value\n * @return {Boolean}\n */ exports1.node = function(value) {\n                    return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;\n                };\n                /**\n * Check if argument is a list of HTML elements.\n *\n * @param {Object} value\n * @return {Boolean}\n */ exports1.nodeList = function(value) {\n                    var type = Object.prototype.toString.call(value);\n                    return value !== undefined && (type === \"[object NodeList]\" || type === \"[object HTMLCollection]\") && \"length\" in value && (value.length === 0 || exports1.node(value[0]));\n                };\n                /**\n * Check if argument is a string.\n *\n * @param {Object} value\n * @return {Boolean}\n */ exports1.string = function(value) {\n                    return typeof value === \"string\" || value instanceof String;\n                };\n                /**\n * Check if argument is a function.\n *\n * @param {Object} value\n * @return {Boolean}\n */ exports1.fn = function(value) {\n                    var type = Object.prototype.toString.call(value);\n                    return type === \"[object Function]\";\n                };\n            /***/ },\n            /***/ 370: /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_26467__) {\n                var is = __nested_webpack_require_26467__(879);\n                var delegate = __nested_webpack_require_26467__(438);\n                /**\n * Validates all params and calls the right\n * listener function based on its target type.\n *\n * @param {String|HTMLElement|HTMLCollection|NodeList} target\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */ function listen(target, type, callback) {\n                    if (!target && !type && !callback) {\n                        throw new Error(\"Missing required arguments\");\n                    }\n                    if (!is.string(type)) {\n                        throw new TypeError(\"Second argument must be a String\");\n                    }\n                    if (!is.fn(callback)) {\n                        throw new TypeError(\"Third argument must be a Function\");\n                    }\n                    if (is.node(target)) {\n                        return listenNode(target, type, callback);\n                    } else if (is.nodeList(target)) {\n                        return listenNodeList(target, type, callback);\n                    } else if (is.string(target)) {\n                        return listenSelector(target, type, callback);\n                    } else {\n                        throw new TypeError(\"First argument must be a String, HTMLElement, HTMLCollection, or NodeList\");\n                    }\n                }\n                /**\n * Adds an event listener to a HTML element\n * and returns a remove listener function.\n *\n * @param {HTMLElement} node\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */ function listenNode(node, type, callback) {\n                    node.addEventListener(type, callback);\n                    return {\n                        destroy: function() {\n                            node.removeEventListener(type, callback);\n                        }\n                    };\n                }\n                /**\n * Add an event listener to a list of HTML elements\n * and returns a remove listener function.\n *\n * @param {NodeList|HTMLCollection} nodeList\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */ function listenNodeList(nodeList, type, callback) {\n                    Array.prototype.forEach.call(nodeList, function(node) {\n                        node.addEventListener(type, callback);\n                    });\n                    return {\n                        destroy: function() {\n                            Array.prototype.forEach.call(nodeList, function(node) {\n                                node.removeEventListener(type, callback);\n                            });\n                        }\n                    };\n                }\n                /**\n * Add an event listener to a selector\n * and returns a remove listener function.\n *\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */ function listenSelector(selector, type, callback) {\n                    return delegate(document.body, selector, type, callback);\n                }\n                module1.exports = listen;\n            /***/ },\n            /***/ 817: /***/ function(module1) {\n                function select(element) {\n                    var selectedText;\n                    if (element.nodeName === \"SELECT\") {\n                        element.focus();\n                        selectedText = element.value;\n                    } else if (element.nodeName === \"INPUT\" || element.nodeName === \"TEXTAREA\") {\n                        var isReadOnly = element.hasAttribute(\"readonly\");\n                        if (!isReadOnly) {\n                            element.setAttribute(\"readonly\", \"\");\n                        }\n                        element.select();\n                        element.setSelectionRange(0, element.value.length);\n                        if (!isReadOnly) {\n                            element.removeAttribute(\"readonly\");\n                        }\n                        selectedText = element.value;\n                    } else {\n                        if (element.hasAttribute(\"contenteditable\")) {\n                            element.focus();\n                        }\n                        var selection = window.getSelection();\n                        var range = document.createRange();\n                        range.selectNodeContents(element);\n                        selection.removeAllRanges();\n                        selection.addRange(range);\n                        selectedText = selection.toString();\n                    }\n                    return selectedText;\n                }\n                module1.exports = select;\n            /***/ },\n            /***/ 279: /***/ function(module1) {\n                function E() {\n                // Keep this empty so it's easier to inherit from\n                // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n                }\n                E.prototype = {\n                    on: function(name, callback, ctx) {\n                        var e = this.e || (this.e = {});\n                        (e[name] || (e[name] = [])).push({\n                            fn: callback,\n                            ctx: ctx\n                        });\n                        return this;\n                    },\n                    once: function(name, callback, ctx) {\n                        var self = this;\n                        function listener() {\n                            self.off(name, listener);\n                            callback.apply(ctx, arguments);\n                        }\n                        ;\n                        listener._ = callback;\n                        return this.on(name, listener, ctx);\n                    },\n                    emit: function(name) {\n                        var data = [].slice.call(arguments, 1);\n                        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n                        var i = 0;\n                        var len = evtArr.length;\n                        for(i; i < len; i++){\n                            evtArr[i].fn.apply(evtArr[i].ctx, data);\n                        }\n                        return this;\n                    },\n                    off: function(name, callback) {\n                        var e = this.e || (this.e = {});\n                        var evts = e[name];\n                        var liveEvents = [];\n                        if (evts && callback) {\n                            for(var i = 0, len = evts.length; i < len; i++){\n                                if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);\n                            }\n                        }\n                        // Remove event from queue to prevent memory leak\n                        // Suggested by https://github.com/lazd\n                        // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n                        liveEvents.length ? e[name] = liveEvents : delete e[name];\n                        return this;\n                    }\n                };\n                module1.exports = E;\n                module1.exports.TinyEmitter = E;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_34042__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ if (__webpack_module_cache__[moduleId]) {\n                /******/ return __webpack_module_cache__[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __nested_webpack_require_34042__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ !function() {\n            /******/ // getDefaultExport function for compatibility with non-harmony modules\n            /******/ __nested_webpack_require_34042__.n = function(module1) {\n                /******/ var getter = module1 && module1.__esModule ? /******/ function() {\n                    return module1[\"default\"];\n                } : /******/ function() {\n                    return module1;\n                };\n                /******/ __nested_webpack_require_34042__.d(getter, {\n                    a: getter\n                });\n                /******/ return getter;\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/define property getters */ /******/ !function() {\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_34042__.d = function(exports1, definition) {\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_34042__.o(definition, key) && !__nested_webpack_require_34042__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ !function() {\n            /******/ __nested_webpack_require_34042__.o = function(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            };\n        /******/ }();\n        /******/ /************************************************************************/ /******/ // module exports must be returned from runtime so entry inlining is disabled\n        /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_34042__(686);\n    /******/ }().default;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2xpcGJvYXJkL2Rpc3QvY2xpcGJvYXJkLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztDQUtDLEdBQ0EsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRDtTQUNiLEVBSzRCQTtBQUNsQyxHQUFHLElBQUksRUFBRTtJQUNULE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUksSUFBSUssc0JBQXVCO1lBRXJDLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxTQUFTQyx1QkFBdUIsRUFBRUMsMEJBQW1CLEVBQUVDLDhCQUFtQjtnQkFFakY7Z0JBRUEsVUFBVTtnQkFDVkEsOEJBQW1CQSxDQUFDQyxDQUFDLENBQUNGLDBCQUFtQkEsRUFBRTtvQkFDekMsV0FBVzt3QkFBYSxPQUFPLFdBQVcsR0FBR0c7b0JBQVc7Z0JBQzFEO2dCQUVBLHdEQUF3RDtnQkFDeEQsSUFBSUMsZUFBZUgsOEJBQW1CQSxDQUFDO2dCQUN2QyxJQUFJSSx1QkFBdUIsV0FBVyxHQUFFSiw4QkFBbUJBLENBQUNLLENBQUMsQ0FBQ0Y7Z0JBQzlELDhEQUE4RDtnQkFDOUQsSUFBSUcsU0FBU04sOEJBQW1CQSxDQUFDO2dCQUNqQyxJQUFJTyxpQkFBaUIsV0FBVyxHQUFFUCw4QkFBbUJBLENBQUNLLENBQUMsQ0FBQ0M7Z0JBQ3hELHVEQUF1RDtnQkFDdkQsSUFBSUUsYUFBYVIsOEJBQW1CQSxDQUFDO2dCQUNyQyxJQUFJUyxpQkFBaUIsV0FBVyxHQUFFVCw4QkFBbUJBLENBQUNLLENBQUMsQ0FBQ0c7a0JBQ3ZELCtDQUErQztnQkFDaEQ7Ozs7Q0FJQyxHQUNELFNBQVNFLFFBQVFDLElBQUk7b0JBQ25CLElBQUk7d0JBQ0YsT0FBT0MsU0FBU0MsV0FBVyxDQUFDRjtvQkFDOUIsRUFBRSxPQUFPRyxLQUFLO3dCQUNaLE9BQU87b0JBQ1Q7Z0JBQ0Y7a0JBQ0MsNENBQTRDO2dCQUc3Qzs7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SztRQUNYLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FDTixNQUFNLEdBQUksMkNBQTJDLEdBQ3JELE1BQU0sR0FBSSxDQUFDO1lBQ1gsTUFBTSxHQUFLLDhDQUE4QztZQUN6RCxNQUFNLEdBQUtuTixnQ0FBbUJBLENBQUNDLENBQUMsR0FBRyxTQUFTUixRQUFPLEVBQUU2TixVQUFVO2dCQUMvRCxNQUFNLEdBQU0sSUFBSSxJQUFJdEksT0FBT3NJLFdBQVk7b0JBQ3ZDLE1BQU0sR0FBTyxJQUFHdE4sZ0NBQW1CQSxDQUFDeUYsQ0FBQyxDQUFDNkgsWUFBWXRJLFFBQVEsQ0FBQ2hGLGdDQUFtQkEsQ0FBQ3lGLENBQUMsQ0FBQ2hHLFVBQVN1RixNQUFNO3dCQUNoRyxNQUFNLEdBQVFGLE9BQU9DLGNBQWMsQ0FBQ3RGLFVBQVN1RixLQUFLOzRCQUFFTCxZQUFZOzRCQUFNNEksS0FBS0QsVUFBVSxDQUFDdEksSUFBSTt3QkFBQztvQkFDM0YsTUFBTSxHQUFPO2dCQUNiLE1BQU0sR0FBTTtZQUNaLE1BQU0sR0FBSztRQUNYLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FDTixNQUFNLEdBQUksNENBQTRDLEdBQ3RELE1BQU0sR0FBSSxDQUFDO1lBQ1gsTUFBTSxHQUFLaEYsZ0NBQW1CQSxDQUFDeUYsQ0FBQyxHQUFHLFNBQVNwQyxHQUFHLEVBQUVtSyxJQUFJO2dCQUFJLE9BQU8xSSxPQUFPckIsU0FBUyxDQUFDZ0ssY0FBYyxDQUFDOUcsSUFBSSxDQUFDdEQsS0FBS21LO1lBQU87UUFDakgsTUFBTSxHQUFJO1FBQ1YsTUFBTSxHQUNOLHdFQUF3RSxHQUN4RSxNQUFNLEdBQUksNkVBQTZFO1FBQ3ZGLE1BQU0sR0FBSSxVQUFVO1FBQ3BCLE1BQU0sR0FBSSx1Q0FBdUM7UUFDakQsTUFBTSxHQUFJLE9BQU94TixnQ0FBbUJBLENBQUM7SUFDckMsTUFBTSxHQUFHLElBQ1IwTixPQUFPO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Z3B0LWxpdGUvLi9ub2RlX21vZHVsZXMvY2xpcGJvYXJkL2Rpc3QvY2xpcGJvYXJkLmpzPzcxMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBjbGlwYm9hcmQuanMgdjIuMC4xMVxuICogaHR0cHM6Ly9jbGlwYm9hcmRqcy5jb20vXG4gKlxuICogTGljZW5zZWQgTUlUIMKpIFplbm8gUm9jaGFcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQ2xpcGJvYXJkSlNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQ2xpcGJvYXJkSlNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA2ODY6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwiZGVmYXVsdFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gY2xpcGJvYXJkOyB9XG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy90aW55LWVtaXR0ZXIvaW5kZXguanNcbnZhciB0aW55X2VtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3OSk7XG52YXIgdGlueV9lbWl0dGVyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHRpbnlfZW1pdHRlcik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2dvb2QtbGlzdGVuZXIvc3JjL2xpc3Rlbi5qc1xudmFyIGxpc3RlbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzcwKTtcbnZhciBsaXN0ZW5fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obGlzdGVuKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvc2VsZWN0L3NyYy9zZWxlY3QuanNcbnZhciBzcmNfc2VsZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTcpO1xudmFyIHNlbGVjdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihzcmNfc2VsZWN0KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21tb24vY29tbWFuZC5qc1xuLyoqXG4gKiBFeGVjdXRlcyBhIGdpdmVuIG9wZXJhdGlvbiB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbW1hbmQodHlwZSkge1xuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5leGVjQ29tbWFuZCh0eXBlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYWN0aW9ucy9jdXQuanNcblxuXG4vKipcbiAqIEN1dCBhY3Rpb24gd3JhcHBlci5cbiAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSB0YXJnZXRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgQ2xpcGJvYXJkQWN0aW9uQ3V0ID0gZnVuY3Rpb24gQ2xpcGJvYXJkQWN0aW9uQ3V0KHRhcmdldCkge1xuICB2YXIgc2VsZWN0ZWRUZXh0ID0gc2VsZWN0X2RlZmF1bHQoKSh0YXJnZXQpO1xuICBjb21tYW5kKCdjdXQnKTtcbiAgcmV0dXJuIHNlbGVjdGVkVGV4dDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGFjdGlvbnNfY3V0ID0gKENsaXBib2FyZEFjdGlvbkN1dCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tbW9uL2NyZWF0ZS1mYWtlLWVsZW1lbnQuanNcbi8qKlxuICogQ3JlYXRlcyBhIGZha2UgdGV4dGFyZWEgZWxlbWVudCB3aXRoIGEgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVGYWtlRWxlbWVudCh2YWx1ZSkge1xuICB2YXIgaXNSVEwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKSA9PT0gJ3J0bCc7XG4gIHZhciBmYWtlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7IC8vIFByZXZlbnQgem9vbWluZyBvbiBpT1NcblxuICBmYWtlRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9ICcxMnB0JzsgLy8gUmVzZXQgYm94IG1vZGVsXG5cbiAgZmFrZUVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzAnO1xuICBmYWtlRWxlbWVudC5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICBmYWtlRWxlbWVudC5zdHlsZS5tYXJnaW4gPSAnMCc7IC8vIE1vdmUgZWxlbWVudCBvdXQgb2Ygc2NyZWVuIGhvcml6b250YWxseVxuXG4gIGZha2VFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZmFrZUVsZW1lbnQuc3R5bGVbaXNSVEwgPyAncmlnaHQnIDogJ2xlZnQnXSA9ICctOTk5OXB4JzsgLy8gTW92ZSBlbGVtZW50IHRvIHRoZSBzYW1lIHBvc2l0aW9uIHZlcnRpY2FsbHlcblxuICB2YXIgeVBvc2l0aW9uID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gIGZha2VFbGVtZW50LnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHlQb3NpdGlvbiwgXCJweFwiKTtcbiAgZmFrZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICcnKTtcbiAgZmFrZUVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIGZha2VFbGVtZW50O1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2FjdGlvbnMvY29weS5qc1xuXG5cblxuLyoqXG4gKiBDcmVhdGUgZmFrZSBjb3B5IGFjdGlvbiB3cmFwcGVyIHVzaW5nIGEgZmFrZSBlbGVtZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG52YXIgZmFrZUNvcHlBY3Rpb24gPSBmdW5jdGlvbiBmYWtlQ29weUFjdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgZmFrZUVsZW1lbnQgPSBjcmVhdGVGYWtlRWxlbWVudCh2YWx1ZSk7XG4gIG9wdGlvbnMuY29udGFpbmVyLmFwcGVuZENoaWxkKGZha2VFbGVtZW50KTtcbiAgdmFyIHNlbGVjdGVkVGV4dCA9IHNlbGVjdF9kZWZhdWx0KCkoZmFrZUVsZW1lbnQpO1xuICBjb21tYW5kKCdjb3B5Jyk7XG4gIGZha2VFbGVtZW50LnJlbW92ZSgpO1xuICByZXR1cm4gc2VsZWN0ZWRUZXh0O1xufTtcbi8qKlxuICogQ29weSBhY3Rpb24gd3JhcHBlci5cbiAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuXG52YXIgQ2xpcGJvYXJkQWN0aW9uQ29weSA9IGZ1bmN0aW9uIENsaXBib2FyZEFjdGlvbkNvcHkodGFyZ2V0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgY29udGFpbmVyOiBkb2N1bWVudC5ib2R5XG4gIH07XG4gIHZhciBzZWxlY3RlZFRleHQgPSAnJztcblxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICBzZWxlY3RlZFRleHQgPSBmYWtlQ29weUFjdGlvbih0YXJnZXQsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgIVsndGV4dCcsICdzZWFyY2gnLCAndXJsJywgJ3RlbCcsICdwYXNzd29yZCddLmluY2x1ZGVzKHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC50eXBlKSkge1xuICAgIC8vIElmIGlucHV0IHR5cGUgZG9lc24ndCBzdXBwb3J0IGBzZXRTZWxlY3Rpb25SYW5nZWAuIFNpbXVsYXRlIGl0LiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTElucHV0RWxlbWVudC9zZXRTZWxlY3Rpb25SYW5nZVxuICAgIHNlbGVjdGVkVGV4dCA9IGZha2VDb3B5QWN0aW9uKHRhcmdldC52YWx1ZSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0ZWRUZXh0ID0gc2VsZWN0X2RlZmF1bHQoKSh0YXJnZXQpO1xuICAgIGNvbW1hbmQoJ2NvcHknKTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3RlZFRleHQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhY3Rpb25zX2NvcHkgPSAoQ2xpcGJvYXJkQWN0aW9uQ29weSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYWN0aW9ucy9kZWZhdWx0LmpzXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cblxuXG4vKipcbiAqIElubmVyIGZ1bmN0aW9uIHdoaWNoIHBlcmZvcm1zIHNlbGVjdGlvbiBmcm9tIGVpdGhlciBgdGV4dGAgb3IgYHRhcmdldGBcbiAqIHByb3BlcnRpZXMgYW5kIHRoZW4gZXhlY3V0ZXMgY29weSBvciBjdXQgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxudmFyIENsaXBib2FyZEFjdGlvbkRlZmF1bHQgPSBmdW5jdGlvbiBDbGlwYm9hcmRBY3Rpb25EZWZhdWx0KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIC8vIERlZmluZXMgYmFzZSBwcm9wZXJ0aWVzIHBhc3NlZCBmcm9tIGNvbnN0cnVjdG9yLlxuICB2YXIgX29wdGlvbnMkYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24sXG4gICAgICBhY3Rpb24gPSBfb3B0aW9ucyRhY3Rpb24gPT09IHZvaWQgMCA/ICdjb3B5JyA6IF9vcHRpb25zJGFjdGlvbixcbiAgICAgIGNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyLFxuICAgICAgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQsXG4gICAgICB0ZXh0ID0gb3B0aW9ucy50ZXh0OyAvLyBTZXRzIHRoZSBgYWN0aW9uYCB0byBiZSBwZXJmb3JtZWQgd2hpY2ggY2FuIGJlIGVpdGhlciAnY29weScgb3IgJ2N1dCcuXG5cbiAgaWYgKGFjdGlvbiAhPT0gJ2NvcHknICYmIGFjdGlvbiAhPT0gJ2N1dCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJhY3Rpb25cIiB2YWx1ZSwgdXNlIGVpdGhlciBcImNvcHlcIiBvciBcImN1dFwiJyk7XG4gIH0gLy8gU2V0cyB0aGUgYHRhcmdldGAgcHJvcGVydHkgdXNpbmcgYW4gZWxlbWVudCB0aGF0IHdpbGwgYmUgaGF2ZSBpdHMgY29udGVudCBjb3BpZWQuXG5cblxuICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGFyZ2V0ICYmIF90eXBlb2YodGFyZ2V0KSA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICBpZiAoYWN0aW9uID09PSAnY29weScgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJ0YXJnZXRcIiBhdHRyaWJ1dGUuIFBsZWFzZSB1c2UgXCJyZWFkb25seVwiIGluc3RlYWQgb2YgXCJkaXNhYmxlZFwiIGF0dHJpYnV0ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aW9uID09PSAnY3V0JyAmJiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKSB8fCB0YXJnZXQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJ0YXJnZXRcIiBhdHRyaWJ1dGUuIFlvdSBjYW5cXCd0IGN1dCB0ZXh0IGZyb20gZWxlbWVudHMgd2l0aCBcInJlYWRvbmx5XCIgb3IgXCJkaXNhYmxlZFwiIGF0dHJpYnV0ZXMnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwidGFyZ2V0XCIgdmFsdWUsIHVzZSBhIHZhbGlkIEVsZW1lbnQnKTtcbiAgICB9XG4gIH0gLy8gRGVmaW5lIHNlbGVjdGlvbiBzdHJhdGVneSBiYXNlZCBvbiBgdGV4dGAgcHJvcGVydHkuXG5cblxuICBpZiAodGV4dCkge1xuICAgIHJldHVybiBhY3Rpb25zX2NvcHkodGV4dCwge1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgICB9KTtcbiAgfSAvLyBEZWZpbmVzIHdoaWNoIHNlbGVjdGlvbiBzdHJhdGVneSBiYXNlZCBvbiBgdGFyZ2V0YCBwcm9wZXJ0eS5cblxuXG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gYWN0aW9uID09PSAnY3V0JyA/IGFjdGlvbnNfY3V0KHRhcmdldCkgOiBhY3Rpb25zX2NvcHkodGFyZ2V0LCB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICAgIH0pO1xuICB9XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBhY3Rpb25zX2RlZmF1bHQgPSAoQ2xpcGJvYXJkQWN0aW9uRGVmYXVsdCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY2xpcGJvYXJkLmpzXG5mdW5jdGlvbiBjbGlwYm9hcmRfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBjbGlwYm9hcmRfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IGNsaXBib2FyZF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gY2xpcGJvYXJkX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoY2xpcGJvYXJkX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblxuXG5cblxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byByZXRyaWV2ZSBhdHRyaWJ1dGUgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3VmZml4XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShzdWZmaXgsIGVsZW1lbnQpIHtcbiAgdmFyIGF0dHJpYnV0ZSA9IFwiZGF0YS1jbGlwYm9hcmQtXCIuY29uY2F0KHN1ZmZpeCk7XG5cbiAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3Mgd2hpY2ggdGFrZXMgb25lIG9yIG1vcmUgZWxlbWVudHMsIGFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZW0sXG4gKiBhbmQgaW5zdGFudGlhdGVzIGEgbmV3IGBDbGlwYm9hcmRBY3Rpb25gIG9uIGVhY2ggY2xpY2suXG4gKi9cblxuXG52YXIgQ2xpcGJvYXJkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW1pdHRlcikge1xuICBfaW5oZXJpdHMoQ2xpcGJvYXJkLCBfRW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDbGlwYm9hcmQpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdH0gdHJpZ2dlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2xpcGJvYXJkKHRyaWdnZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpcGJvYXJkKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBfdGhpcy5yZXNvbHZlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIF90aGlzLmxpc3RlbkNsaWNrKHRyaWdnZXIpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBEZWZpbmVzIGlmIGF0dHJpYnV0ZXMgd291bGQgYmUgcmVzb2x2ZWQgdXNpbmcgaW50ZXJuYWwgc2V0dGVyIGZ1bmN0aW9uc1xuICAgKiBvciBjdXN0b20gZnVuY3Rpb25zIHRoYXQgd2VyZSBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhDbGlwYm9hcmQsIFt7XG4gICAga2V5OiBcInJlc29sdmVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdGhpcy5hY3Rpb24gPSB0eXBlb2Ygb3B0aW9ucy5hY3Rpb24gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmFjdGlvbiA6IHRoaXMuZGVmYXVsdEFjdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdHlwZW9mIG9wdGlvbnMudGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50YXJnZXQgOiB0aGlzLmRlZmF1bHRUYXJnZXQ7XG4gICAgICB0aGlzLnRleHQgPSB0eXBlb2Ygb3B0aW9ucy50ZXh0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50ZXh0IDogdGhpcy5kZWZhdWx0VGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY2xpcGJvYXJkX3R5cGVvZihvcHRpb25zLmNvbnRhaW5lcikgPT09ICdvYmplY3QnID8gb3B0aW9ucy5jb250YWluZXIgOiBkb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY2xpY2sgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHBhc3NlZCB0cmlnZ2VyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fEhUTUxDb2xsZWN0aW9ufE5vZGVMaXN0fSB0cmlnZ2VyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsaXN0ZW5DbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5DbGljayh0cmlnZ2VyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3Rlbl9kZWZhdWx0KCkodHJpZ2dlciwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5vbkNsaWNrKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgYSBuZXcgYENsaXBib2FyZEFjdGlvbmAgb24gZWFjaCBjbGljayBldmVudC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbkNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgICAgdmFyIHRyaWdnZXIgPSBlLmRlbGVnYXRlVGFyZ2V0IHx8IGUuY3VycmVudFRhcmdldDtcbiAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbih0cmlnZ2VyKSB8fCAnY29weSc7XG4gICAgICB2YXIgdGV4dCA9IGFjdGlvbnNfZGVmYXVsdCh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0KHRyaWdnZXIpLFxuICAgICAgICB0ZXh0OiB0aGlzLnRleHQodHJpZ2dlcilcbiAgICAgIH0pOyAvLyBGaXJlcyBhbiBldmVudCBiYXNlZCBvbiB0aGUgY29weSBvcGVyYXRpb24gcmVzdWx0LlxuXG4gICAgICB0aGlzLmVtaXQodGV4dCA/ICdzdWNjZXNzJyA6ICdlcnJvcicsIHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHRyaWdnZXI6IHRyaWdnZXIsXG4gICAgICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgICAgICBpZiAodHJpZ2dlcikge1xuICAgICAgICAgICAgdHJpZ2dlci5mb2N1cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgYGFjdGlvbmAgbG9va3VwIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdHJpZ2dlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdEFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0QWN0aW9uKHRyaWdnZXIpIHtcbiAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVWYWx1ZSgnYWN0aW9uJywgdHJpZ2dlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgYHRhcmdldGAgbG9va3VwIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdHJpZ2dlclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdFRhcmdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0VGFyZ2V0KHRyaWdnZXIpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IGdldEF0dHJpYnV0ZVZhbHVlKCd0YXJnZXQnLCB0cmlnZ2VyKTtcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3cgZmlyZSBwcm9ncmFtbWF0aWNhbGx5IGEgY29weSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyBUZXh0IGNvcGllZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRUZXh0XCIsXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGB0ZXh0YCBsb29rdXAgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0cmlnZ2VyXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRUZXh0KHRyaWdnZXIpIHtcbiAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVWYWx1ZSgndGV4dCcsIHRyaWdnZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGxpZmVjeWNsZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvcHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29weSh0YXJnZXQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuYm9keVxuICAgICAgfTtcbiAgICAgIHJldHVybiBhY3Rpb25zX2NvcHkodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3cgZmlyZSBwcm9ncmFtbWF0aWNhbGx5IGEgY3V0IGFjdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEhUTUxFbGVtZW50fSB0YXJnZXRcbiAgICAgKiBAcmV0dXJucyBUZXh0IGN1dHRlZC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImN1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gYWN0aW9uc19jdXQodGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3VwcG9ydCBvZiB0aGUgZ2l2ZW4gYWN0aW9uLCBvciBhbGwgYWN0aW9ucyBpZiBubyBhY3Rpb24gaXNcbiAgICAgKiBnaXZlbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2FjdGlvbl1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzU3VwcG9ydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogWydjb3B5JywgJ2N1dCddO1xuICAgICAgdmFyIGFjdGlvbnMgPSB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IFthY3Rpb25dIDogYWN0aW9uO1xuICAgICAgdmFyIHN1cHBvcnQgPSAhIWRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZDtcbiAgICAgIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHN1cHBvcnQgPSBzdXBwb3J0ICYmICEhZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKGFjdGlvbik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzdXBwb3J0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGlwYm9hcmQ7XG59KCh0aW55X2VtaXR0ZXJfZGVmYXVsdCgpKSk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaXBib2FyZCA9IChDbGlwYm9hcmQpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODI4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG52YXIgRE9DVU1FTlRfTk9ERV9UWVBFID0gOTtcblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBFbGVtZW50Lm1hdGNoZXMoKVxuICovXG5pZiAodHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmICFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgdmFyIHByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5tYXRjaGVzID0gcHJvdG8ubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBwcm90by5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBwcm90by5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgdGhhdCBtYXRjaGVzIGEgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjbG9zZXN0IChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IERPQ1VNRU5UX05PREVfVFlQRSkge1xuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQubWF0Y2hlcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb3Nlc3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xvc2VzdCA9IF9fd2VicGFja19yZXF1aXJlX18oODI4KTtcblxuLyoqXG4gKiBEZWxlZ2F0ZXMgZXZlbnQgdG8gYSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHVzZUNhcHR1cmVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gX2RlbGVnYXRlKGVsZW1lbnQsIHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICAgIHZhciBsaXN0ZW5lckZuID0gbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lckZuLCB1c2VDYXB0dXJlKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyRm4sIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIERlbGVnYXRlcyBldmVudCB0byBhIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd8QXJyYXl9IFtlbGVtZW50c11cbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHVzZUNhcHR1cmVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGVsZWdhdGUoZWxlbWVudHMsIHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xuICAgIC8vIEhhbmRsZSB0aGUgcmVndWxhciBFbGVtZW50IHVzYWdlXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50cy5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBfZGVsZWdhdGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgRWxlbWVudC1sZXNzIHVzYWdlLCBpdCBkZWZhdWx0cyB0byBnbG9iYWwgZGVsZWdhdGlvblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgYGRvY3VtZW50YCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLCB0aGVuIGFwcGx5IGFyZ3VtZW50c1xuICAgICAgICAvLyBUaGlzIGlzIGEgc2hvcnQgd2F5IHRvIC51bnNoaWZ0IGBhcmd1bWVudHNgIHdpdGhvdXQgcnVubmluZyBpbnRvIGRlb3B0aW1pemF0aW9uc1xuICAgICAgICByZXR1cm4gX2RlbGVnYXRlLmJpbmQobnVsbCwgZG9jdW1lbnQpLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIFNlbGVjdG9yLWJhc2VkIHVzYWdlXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgQXJyYXktbGlrZSBiYXNlZCB1c2FnZVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBfZGVsZWdhdGUoZWxlbWVudCwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBGaW5kcyBjbG9zZXN0IG1hdGNoIGFuZCBpbnZva2VzIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBsaXN0ZW5lcihlbGVtZW50LCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLmRlbGVnYXRlVGFyZ2V0ID0gY2xvc2VzdChlLnRhcmdldCwgc2VsZWN0b3IpO1xuXG4gICAgICAgIGlmIChlLmRlbGVnYXRlVGFyZ2V0KSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKGVsZW1lbnQsIGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlbGVnYXRlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4Nzk6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMubm9kZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgICAgICAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBsaXN0IG9mIEhUTUwgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLm5vZGVMaXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAmJiAodHlwZSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKVxuICAgICAgICAmJiAoJ2xlbmd0aCcgaW4gdmFsdWUpXG4gICAgICAgICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgZXhwb3J0cy5ub2RlKHZhbHVlWzBdKSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFyZ3VtZW50IGlzIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5zdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5mbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzkpO1xudmFyIGRlbGVnYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzgpO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhbGwgcGFyYW1zIGFuZCBjYWxscyB0aGUgcmlnaHRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9uIGJhc2VkIG9uIGl0cyB0YXJnZXQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRhcmdldCAmJiAhdHlwZSAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIGlmICghaXMuc3RyaW5nKHR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgU3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFpcy5mbihjYWxsYmFjaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcmQgYXJndW1lbnQgbXVzdCBiZSBhIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzLm5vZGUodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbGlzdGVuTm9kZSh0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXMubm9kZUxpc3QodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbGlzdGVuTm9kZUxpc3QodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzLnN0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5TZWxlY3Rvcih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBTdHJpbmcsIEhUTUxFbGVtZW50LCBIVE1MQ29sbGVjdGlvbiwgb3IgTm9kZUxpc3QnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byBhIEhUTUwgZWxlbWVudFxuICogYW5kIHJldHVybnMgYSByZW1vdmUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbk5vZGUobm9kZSwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhIGxpc3Qgb2YgSFRNTCBlbGVtZW50c1xuICogYW5kIHJldHVybnMgYSByZW1vdmUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtOb2RlTGlzdHxIVE1MQ29sbGVjdGlvbn0gbm9kZUxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5Ob2RlTGlzdChub2RlTGlzdCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobm9kZUxpc3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGEgc2VsZWN0b3JcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGxpc3RlblNlbGVjdG9yKHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkZWxlZ2F0ZShkb2N1bWVudC5ib2R5LCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RlbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODE3OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5mdW5jdGlvbiBzZWxlY3QoZWxlbWVudCkge1xuICAgIHZhciBzZWxlY3RlZFRleHQ7XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuXG4gICAgICAgIHNlbGVjdGVkVGV4dCA9IGVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdJTlBVVCcgfHwgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICB2YXIgaXNSZWFkT25seSA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpO1xuXG4gICAgICAgIGlmICghaXNSZWFkT25seSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5zZWxlY3QoKTtcbiAgICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSgwLCBlbGVtZW50LnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncmVhZG9ubHknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdGVkVGV4dCA9IGVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhlbGVtZW50KTtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgIHNlbGVjdGVkVGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RlZFRleHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VsZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNzk6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbmZ1bmN0aW9uIEUgKCkge1xuICAvLyBLZWVwIHRoaXMgZW1wdHkgc28gaXQncyBlYXNpZXIgdG8gaW5oZXJpdCBmcm9tXG4gIC8vICh2aWEgaHR0cHM6Ly9naXRodWIuY29tL2xpcHNtYWNrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9pc3N1ZXMvMylcbn1cblxuRS5wcm90b3R5cGUgPSB7XG4gIG9uOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgIHZhciBlID0gdGhpcy5lIHx8ICh0aGlzLmUgPSB7fSk7XG5cbiAgICAoZVtuYW1lXSB8fCAoZVtuYW1lXSA9IFtdKSkucHVzaCh7XG4gICAgICBmbjogY2FsbGJhY2ssXG4gICAgICBjdHg6IGN0eFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25jZTogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIgKCkge1xuICAgICAgc2VsZi5vZmYobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgY2FsbGJhY2suYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lci5fID0gY2FsbGJhY2tcbiAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBsaXN0ZW5lciwgY3R4KTtcbiAgfSxcblxuICBlbWl0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBkYXRhID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBldnRBcnIgPSAoKHRoaXMuZSB8fCAodGhpcy5lID0ge30pKVtuYW1lXSB8fCBbXSkuc2xpY2UoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGV2dEFyci5sZW5ndGg7XG5cbiAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xuICAgICAgZXZ0QXJyW2ldLmZuLmFwcGx5KGV2dEFycltpXS5jdHgsIGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9mZjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcbiAgICB2YXIgZXZ0cyA9IGVbbmFtZV07XG4gICAgdmFyIGxpdmVFdmVudHMgPSBbXTtcblxuICAgIGlmIChldnRzICYmIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZXZ0c1tpXS5mbiAhPT0gY2FsbGJhY2sgJiYgZXZ0c1tpXS5mbi5fICE9PSBjYWxsYmFjaylcbiAgICAgICAgICBsaXZlRXZlbnRzLnB1c2goZXZ0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGZyb20gcXVldWUgdG8gcHJldmVudCBtZW1vcnkgbGVha1xuICAgIC8vIFN1Z2dlc3RlZCBieSBodHRwczovL2dpdGh1Yi5jb20vbGF6ZFxuICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9jb21taXQvYzZlYmZhYTliYzk3M2IzM2QxMTBhODRhMzA3NzQyYjdjZjk0Yzk1MyNjb21taXRjb21tZW50LTUwMjQ5MTBcblxuICAgIChsaXZlRXZlbnRzLmxlbmd0aClcbiAgICAgID8gZVtuYW1lXSA9IGxpdmVFdmVudHNcbiAgICAgIDogZGVsZXRlIGVbbmFtZV07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFO1xubW9kdWxlLmV4cG9ydHMuVGlueUVtaXR0ZXIgPSBFO1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7IH1cbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIG1vZHVsZSBleHBvcnRzIG11c3QgYmUgcmV0dXJuZWQgZnJvbSBydW50aW1lIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4Nik7XG4vKioqKioqLyB9KSgpXG4uZGVmYXVsdDtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIl9fd2VicGFja19tb2R1bGVzX18iLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiZCIsImNsaXBib2FyZCIsInRpbnlfZW1pdHRlciIsInRpbnlfZW1pdHRlcl9kZWZhdWx0IiwibiIsImxpc3RlbiIsImxpc3Rlbl9kZWZhdWx0Iiwic3JjX3NlbGVjdCIsInNlbGVjdF9kZWZhdWx0IiwiY29tbWFuZCIsInR5cGUiLCJkb2N1bWVudCIsImV4ZWNDb21tYW5kIiwiZXJyIiwiQ2xpcGJvYXJkQWN0aW9uQ3V0IiwidGFyZ2V0Iiwic2VsZWN0ZWRUZXh0IiwiYWN0aW9uc19jdXQiLCJjcmVhdGVGYWtlRWxlbWVudCIsInZhbHVlIiwiaXNSVEwiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJmYWtlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImZvbnRTaXplIiwiYm9yZGVyIiwicGFkZGluZyIsIm1hcmdpbiIsInBvc2l0aW9uIiwieVBvc2l0aW9uIiwid2luZG93IiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJ0b3AiLCJjb25jYXQiLCJzZXRBdHRyaWJ1dGUiLCJmYWtlQ29weUFjdGlvbiIsIm9wdGlvbnMiLCJjb250YWluZXIiLCJhcHBlbmRDaGlsZCIsInJlbW92ZSIsIkNsaXBib2FyZEFjdGlvbkNvcHkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJib2R5IiwiSFRNTElucHV0RWxlbWVudCIsImluY2x1ZGVzIiwiYWN0aW9uc19jb3B5IiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJDbGlwYm9hcmRBY3Rpb25EZWZhdWx0IiwiX29wdGlvbnMkYWN0aW9uIiwiYWN0aW9uIiwidGV4dCIsIkVycm9yIiwibm9kZVR5cGUiLCJoYXNBdHRyaWJ1dGUiLCJhY3Rpb25zX2RlZmF1bHQiLCJjbGlwYm9hcmRfdHlwZW9mIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJpIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwiX3NldFByb3RvdHlwZU9mIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIl9jcmVhdGVTdXBlciIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIl9jcmVhdGVTdXBlckludGVybmFsIiwiU3VwZXIiLCJfZ2V0UHJvdG90eXBlT2YiLCJyZXN1bHQiLCJOZXdUYXJnZXQiLCJSZWZsZWN0IiwiY29uc3RydWN0IiwiYXBwbHkiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJjYWxsIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwic2hhbSIsIlByb3h5IiwiRGF0ZSIsInRvU3RyaW5nIiwiZSIsImdldFByb3RvdHlwZU9mIiwiZ2V0QXR0cmlidXRlVmFsdWUiLCJzdWZmaXgiLCJlbGVtZW50IiwiYXR0cmlidXRlIiwiQ2xpcGJvYXJkIiwiX0VtaXR0ZXIiLCJfc3VwZXIiLCJ0cmlnZ2VyIiwiX3RoaXMiLCJyZXNvbHZlT3B0aW9ucyIsImxpc3RlbkNsaWNrIiwiZGVmYXVsdEFjdGlvbiIsImRlZmF1bHRUYXJnZXQiLCJkZWZhdWx0VGV4dCIsIl90aGlzMiIsImxpc3RlbmVyIiwib25DbGljayIsImRlbGVnYXRlVGFyZ2V0IiwiY3VycmVudFRhcmdldCIsImVtaXQiLCJjbGVhclNlbGVjdGlvbiIsImZvY3VzIiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwiZGVzdHJveSIsImNvcHkiLCJjdXQiLCJpc1N1cHBvcnRlZCIsImFjdGlvbnMiLCJzdXBwb3J0IiwicXVlcnlDb21tYW5kU3VwcG9ydGVkIiwiZm9yRWFjaCIsIkRPQ1VNRU5UX05PREVfVFlQRSIsIkVsZW1lbnQiLCJtYXRjaGVzIiwicHJvdG8iLCJtYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJjbG9zZXN0IiwicGFyZW50Tm9kZSIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsIl9kZWxlZ2F0ZSIsImNhbGxiYWNrIiwidXNlQ2FwdHVyZSIsImxpc3RlbmVyRm4iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlbGVnYXRlIiwiZWxlbWVudHMiLCJiaW5kIiwicXVlcnlTZWxlY3RvckFsbCIsIkFycmF5IiwibWFwIiwibm9kZSIsIkhUTUxFbGVtZW50Iiwibm9kZUxpc3QiLCJzdHJpbmciLCJTdHJpbmciLCJmbiIsImlzIiwibGlzdGVuTm9kZSIsImxpc3Rlbk5vZGVMaXN0IiwibGlzdGVuU2VsZWN0b3IiLCJzZWxlY3QiLCJub2RlTmFtZSIsImlzUmVhZE9ubHkiLCJzZXRTZWxlY3Rpb25SYW5nZSIsInJlbW92ZUF0dHJpYnV0ZSIsInNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJhZGRSYW5nZSIsIkUiLCJvbiIsIm5hbWUiLCJjdHgiLCJwdXNoIiwib25jZSIsIm9mZiIsIl8iLCJkYXRhIiwic2xpY2UiLCJldnRBcnIiLCJsZW4iLCJldnRzIiwibGl2ZUV2ZW50cyIsIlRpbnlFbWl0dGVyIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJnZXR0ZXIiLCJfX2VzTW9kdWxlIiwiYSIsImRlZmluaXRpb24iLCJnZXQiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/clipboard/dist/clipboard.js\n");

/***/ })

};
;