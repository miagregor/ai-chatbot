"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-raw";
exports.ids = ["vendor-chunks/hast-util-raw"];
exports.modules = {

/***/ "(ssr)/./node_modules/hast-util-raw/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/hast-util-raw/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raw: () => (/* binding */ raw)\n/* harmony export */ });\n/* harmony import */ var _ungap_structured_clone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ungap/structured-clone */ \"(ssr)/./node_modules/@ungap/structured-clone/esm/index.js\");\n/* harmony import */ var hast_util_from_parse5__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! hast-util-from-parse5 */ \"(ssr)/./node_modules/hast-util-from-parse5/lib/index.js\");\n/* harmony import */ var hast_util_to_parse5__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! hast-util-to-parse5 */ \"(ssr)/./node_modules/hast-util-to-parse5/lib/index.js\");\n/* harmony import */ var html_void_elements__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! html-void-elements */ \"(ssr)/./node_modules/html-void-elements/index.js\");\n/* harmony import */ var parse5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! parse5 */ \"(ssr)/./node_modules/parse5/dist/index.js\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-position */ \"(ssr)/./node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var web_namespaces__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! web-namespaces */ \"(ssr)/./node_modules/web-namespaces/index.js\");\n/* harmony import */ var zwitch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zwitch */ \"(ssr)/./node_modules/zwitch/index.js\");\n/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('mdast-util-to-hast').Raw} Raw\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').ParserOptions<DefaultTreeAdapterMap>} ParserOptions\n * @typedef {import('parse5').Token.CharacterToken} CharacterToken\n * @typedef {import('parse5').Token.CommentToken} CommentToken\n * @typedef {import('parse5').Token.DoctypeToken} DoctypeToken\n * @typedef {import('parse5').Token.Location} Location\n * @typedef {import('parse5').Token.TagToken} TagToken\n *\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('vfile').VFile} VFile\n */ /**\n * @typedef Options\n *   Configuration.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {Array<Nodes['type']> | null | undefined} [passThrough]\n *   List of custom hast node types to pass through (as in, keep) (optional).\n *\n *   If the passed through nodes have children, those children are expected to\n *   be hast again and will be handled.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {(node: Nodes) => undefined} handle\n *   Add a hast node to the parser.\n * @property {Options} options\n *   User configuration.\n * @property {Parser<DefaultTreeAdapterMap>} parser\n *   Current parser.\n * @property {boolean} stitches\n *   Whether there are stitches.\n *\n * @typedef {{type: 'comment', value: {stitch: Nodes}}} Stitch\n *   Custom comment-like value we pass through parse5, which contains a\n *   replacement node that weâ€™ll swap back in afterwards.\n */ \n\n\n\n\n\n\n\n\n// Node types associated with MDX.\n// <https://github.com/mdx-js/mdx/blob/8a56312/packages/mdx/lib/node-types.js>\nconst knownMdxNames = new Set([\n    \"mdxFlowExpression\",\n    \"mdxJsxFlowElement\",\n    \"mdxJsxTextElement\",\n    \"mdxTextExpression\",\n    \"mdxjsEsm\"\n]);\n/** @type {ParserOptions} */ const parseOptions = {\n    sourceCodeLocationInfo: true,\n    scriptingEnabled: false\n};\n/**\n * Pass a hast tree through an HTML parser, which will fix nesting, and turn\n * raw nodes into actual nodes.\n *\n * @param {Nodes} tree\n *   Original hast tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   Parsed again tree.\n */ function raw(tree, options) {\n    const document = documentMode(tree);\n    /** @type {(node: Nodes, state: State) => undefined} */ const one = (0,zwitch__WEBPACK_IMPORTED_MODULE_2__.zwitch)(\"type\", {\n        handlers: {\n            root,\n            element,\n            text,\n            comment,\n            doctype,\n            raw: handleRaw\n        },\n        unknown\n    });\n    /** @type {State} */ const state = {\n        parser: document ? new parse5__WEBPACK_IMPORTED_MODULE_1__.Parser(parseOptions) : parse5__WEBPACK_IMPORTED_MODULE_1__.Parser.getFragmentParser(undefined, parseOptions),\n        handle (node) {\n            one(node, state);\n        },\n        stitches: false,\n        options: options || {}\n    };\n    one(tree, state);\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)());\n    const p5 = document ? state.parser.document : state.parser.getFragment();\n    const result = (0,hast_util_from_parse5__WEBPACK_IMPORTED_MODULE_4__.fromParse5)(p5, {\n        // To do: support `space`?\n        file: state.options.file\n    });\n    if (state.stitches) {\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_5__.visit)(result, \"comment\", function(node, index, parent) {\n            const stitch = /** @type {Stitch} */ /** @type {unknown} */ node;\n            if (stitch.value.stitch && parent && index !== undefined) {\n                /** @type {Array<RootContent>} */ const siblings = parent.children;\n                // @ts-expect-error: assume the stitch is allowed.\n                siblings[index] = stitch.value.stitch;\n                return index;\n            }\n        });\n    }\n    // Unpack if possible and when not given a `root`.\n    if (result.type === \"root\" && result.children.length === 1 && result.children[0].type === tree.type) {\n        return result.children[0];\n    }\n    return result;\n}\n/**\n * Transform all nodes\n *\n * @param {Array<RootContent>} nodes\n *   hast content.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function all(nodes, state) {\n    let index = -1;\n    /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */ if (nodes) {\n        while(++index < nodes.length){\n            state.handle(nodes[index]);\n        }\n    }\n}\n/**\n * Transform a root.\n *\n * @param {Root} node\n *   hast root node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function root(node, state) {\n    all(node.children, state);\n}\n/**\n * Transform an element.\n *\n * @param {Element} node\n *   hast element node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function element(node, state) {\n    startTag(node, state);\n    all(node.children, state);\n    endTag(node, state);\n}\n/**\n * Transform a text.\n *\n * @param {Text} node\n *   hast text node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function text(node, state) {\n    /** @type {CharacterToken} */ const token = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_1__.Token.TokenType.CHARACTER,\n        chars: node.value,\n        location: createParse5Location(node)\n    };\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)(node));\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.currentToken = token;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser._processToken(state.parser.currentToken);\n}\n/**\n * Transform a doctype.\n *\n * @param {Doctype} node\n *   hast doctype node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function doctype(node, state) {\n    /** @type {DoctypeToken} */ const token = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_1__.Token.TokenType.DOCTYPE,\n        name: \"html\",\n        forceQuirks: false,\n        publicId: \"\",\n        systemId: \"\",\n        location: createParse5Location(node)\n    };\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)(node));\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.currentToken = token;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser._processToken(state.parser.currentToken);\n}\n/**\n * Transform a stitch.\n *\n * @param {Nodes} node\n *   unknown node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function stitch(node, state) {\n    // Mark that there are stitches, so we need to walk the tree and revert them.\n    state.stitches = true;\n    /** @type {Nodes} */ const clone = cloneWithoutChildren(node);\n    // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n    // passed through node).\n    if (\"children\" in node && \"children\" in clone) {\n        // Root in root out.\n        const fakeRoot = /** @type {Root} */ raw({\n            type: \"root\",\n            children: node.children\n        }, state.options);\n        clone.children = fakeRoot.children;\n    }\n    // Hack: `value` is supposed to be a string, but as none of the tools\n    // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n    // through.\n    comment({\n        type: \"comment\",\n        value: {\n            stitch: clone\n        }\n    }, state);\n}\n/**\n * Transform a comment (or stitch).\n *\n * @param {Comment | Stitch} node\n *   hast comment node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function comment(node, state) {\n    /** @type {string} */ // @ts-expect-error: we pass stitches through.\n    const data = node.value;\n    /** @type {CommentToken} */ const token = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_1__.Token.TokenType.COMMENT,\n        data,\n        location: createParse5Location(node)\n    };\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)(node));\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.currentToken = token;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser._processToken(state.parser.currentToken);\n}\n/**\n * Transform a raw node.\n *\n * @param {Raw} node\n *   hast raw node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function handleRaw(node, state) {\n    // Reset preprocessor:\n    // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/preprocessor.ts#L18-L31>.\n    state.parser.tokenizer.preprocessor.html = \"\";\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.pos = -1;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.lastGapPos = -2;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.gapStack = [];\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.skipNextNewLine = false;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.lastChunkWritten = false;\n    state.parser.tokenizer.preprocessor.endOfChunkHit = false;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.isEol = false;\n    // Now pass `node.value`.\n    setPoint(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)(node));\n    state.parser.tokenizer.write(node.value, false);\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer._runParsingLoop();\n    // Character references hang, so if we ended there, we need to flush\n    // those too.\n    // We reset the preprocessor as if the document ends here.\n    // Then one single call to the relevant state does the trick, parse5\n    // consumes the whole token.\n    // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\n    // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\n    // Note: a change to `parse5`, which breaks this, was merged but not released.\n    // Investigate when it is.\n    if (state.parser.tokenizer.state === 72 /* NAMED_CHARACTER_REFERENCE */  || state.parser.tokenizer.state === 78 /* NUMERIC_CHARACTER_REFERENCE_END */ ) {\n        // @ts-expect-error: private.\n        // type-coverage:ignore-next-line\n        state.parser.tokenizer.preprocessor.lastChunkWritten = true;\n        /** @type {number} */ // @ts-expect-error: private.\n        // type-coverage:ignore-next-line\n        const cp = state.parser.tokenizer._consume();\n        // @ts-expect-error: private.\n        // type-coverage:ignore-next-line\n        state.parser.tokenizer._callState(cp);\n    }\n}\n/**\n * Crash on an unknown node.\n *\n * @param {unknown} node_\n *   unknown node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Never.\n */ function unknown(node_, state) {\n    const node = /** @type {Nodes} */ node_;\n    if (state.options.passThrough && state.options.passThrough.includes(node.type)) {\n        stitch(node, state);\n    } else {\n        let extra = \"\";\n        if (knownMdxNames.has(node.type)) {\n            extra = \". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax\";\n        }\n        throw new Error(\"Cannot compile `\" + node.type + \"` node\" + extra);\n    }\n}\n/**\n * Reset the tokenizer of a parser.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Point | undefined} point\n *   Point.\n * @returns {undefined}\n *   Nothing.\n */ function resetTokenizer(state, point) {\n    setPoint(state, point);\n    // Process final characters if theyâ€™re still there after hibernating.\n    /** @type {CharacterToken} */ // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    const token = state.parser.tokenizer.currentCharacterToken;\n    if (token && token.location) {\n        token.location.endLine = state.parser.tokenizer.preprocessor.line;\n        token.location.endCol = state.parser.tokenizer.preprocessor.col + 1;\n        token.location.endOffset = state.parser.tokenizer.preprocessor.offset + 1;\n        // @ts-expect-error: private.\n        // type-coverage:ignore-next-line\n        state.parser.currentToken = token;\n        // @ts-expect-error: private.\n        // type-coverage:ignore-next-line\n        state.parser._processToken(state.parser.currentToken);\n    }\n    // Reset tokenizer:\n    // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/index.ts#L187-L223>.\n    // Especially putting it back in the `data` state is useful: some elements,\n    // like textareas and iframes, change the state.\n    // See GH-7.\n    // But also if broken HTML is in `raw`, and then a correct element is given.\n    // See GH-11.\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.paused = false;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.inLoop = false;\n    // Note: donâ€™t reset `state`, `inForeignNode`, or `lastStartTagName`, we\n    // manually update those when needed.\n    state.parser.tokenizer.active = false;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.returnState = parse5__WEBPACK_IMPORTED_MODULE_1__.TokenizerMode.DATA;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.charRefCode = -1;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.consumedAfterSnapshot = -1;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.currentLocation = null;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.currentCharacterToken = null;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.currentToken = null;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.currentAttr = {\n        name: \"\",\n        value: \"\"\n    };\n}\n/**\n * Set current location.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Point | undefined} point\n *   Point.\n * @returns {undefined}\n *   Nothing.\n */ function setPoint(state, point) {\n    if (point && point.offset !== undefined) {\n        /** @type {Location} */ const location = {\n            startLine: point.line,\n            startCol: point.column,\n            startOffset: point.offset,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1\n        };\n        // @ts-expect-error: private.\n        // type-coverage:ignore-next-line\n        state.parser.tokenizer.preprocessor.lineStartPos = -point.column + 1 // Looks weird, but ensures we get correct positional info.\n        ;\n        state.parser.tokenizer.preprocessor.droppedBufferSize = point.offset;\n        state.parser.tokenizer.preprocessor.line = point.line;\n        // @ts-expect-error: private.\n        // type-coverage:ignore-next-line\n        state.parser.tokenizer.currentLocation = location;\n    }\n}\n/**\n * Emit a start tag.\n *\n * @param {Element} node\n *   Element.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function startTag(node, state) {\n    // Ignore tags if weâ€™re in plain text.\n    if (state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_1__.TokenizerMode.PLAINTEXT) return;\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)(node));\n    const current = state.parser.openElements.current;\n    let ns = \"namespaceURI\" in current ? current.namespaceURI : web_namespaces__WEBPACK_IMPORTED_MODULE_6__.webNamespaces.html;\n    if (ns === web_namespaces__WEBPACK_IMPORTED_MODULE_6__.webNamespaces.html && node.tagName === \"svg\") {\n        ns = web_namespaces__WEBPACK_IMPORTED_MODULE_6__.webNamespaces.svg;\n    }\n    const result = (0,hast_util_to_parse5__WEBPACK_IMPORTED_MODULE_7__.toParse5)(// Shallow clone to not delve into `children`: we only need the attributes.\n    {\n        ...node,\n        children: []\n    }, {\n        space: ns === web_namespaces__WEBPACK_IMPORTED_MODULE_6__.webNamespaces.svg ? \"svg\" : \"html\"\n    });\n    // Always element.\n    /* c8 ignore next */ const attrs = \"attrs\" in result ? result.attrs : [];\n    /** @type {TagToken} */ const tag = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_1__.Token.TokenType.START_TAG,\n        tagName: node.tagName,\n        tagID: parse5__WEBPACK_IMPORTED_MODULE_1__.html.getTagID(node.tagName),\n        // We always send start and end tags.\n        selfClosing: false,\n        ackSelfClosing: false,\n        attrs,\n        location: createParse5Location(node)\n    };\n    // The HTML parsing algorithm works by doing half of the state management in\n    // the tokenizer and half in the parser.\n    // We canâ€™t use the tokenizer here, as we donâ€™t have strings.\n    // So we act *as if* the tokenizer emits tokens:\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.currentToken = tag;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser._processToken(state.parser.currentToken);\n    // â€¦but then we still need a bunch of work that the tokenizer would normally\n    // do, such as:\n    // Set a tag name, similar to how the tokenizer would do it.\n    state.parser.tokenizer.lastStartTagName = node.tagName;\n// `inForeignNode` is correctly set by the parser.\n}\n/**\n * Emit an end tag.\n *\n * @param {Element} node\n *   Element.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */ function endTag(node, state) {\n    // Do not emit closing tags for HTML void elements.\n    if (!state.parser.tokenizer.inForeignNode && html_void_elements__WEBPACK_IMPORTED_MODULE_8__.htmlVoidElements.includes(node.tagName)) {\n        return;\n    }\n    // Ignore tags if weâ€™re in plain text.\n    if (state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_1__.TokenizerMode.PLAINTEXT) return;\n    resetTokenizer(state, (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointEnd)(node));\n    /** @type {TagToken} */ const tag = {\n        type: parse5__WEBPACK_IMPORTED_MODULE_1__.Token.TokenType.END_TAG,\n        tagName: node.tagName,\n        tagID: parse5__WEBPACK_IMPORTED_MODULE_1__.html.getTagID(node.tagName),\n        selfClosing: false,\n        ackSelfClosing: false,\n        attrs: [],\n        location: createParse5Location(node)\n    };\n    // The HTML parsing algorithm works by doing half of the state management in\n    // the tokenizer and half in the parser.\n    // We canâ€™t use the tokenizer here, as we donâ€™t have strings.\n    // So we act *as if* the tokenizer emits tokens:\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.currentToken = tag;\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser._processToken(state.parser.currentToken);\n    // â€¦but then we still need a bunch of work that the tokenizer would normally\n    // do, such as:\n    // Switch back to the data state after alternative states that donâ€™t accept\n    // tags:\n    if (// Current element is closed.\n    tag.tagName === state.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`\n    (state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_1__.TokenizerMode.RCDATA || // `<iframe>`, `<noembed>`, `<style>`, `<xmp>`\n    state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_1__.TokenizerMode.RAWTEXT || // `<script>`\n    state.parser.tokenizer.state === parse5__WEBPACK_IMPORTED_MODULE_1__.TokenizerMode.SCRIPT_DATA)) {\n        state.parser.tokenizer.state = parse5__WEBPACK_IMPORTED_MODULE_1__.TokenizerMode.DATA;\n    }\n}\n/**\n * Check if `node` represents a whole document or a fragment.\n *\n * @param {Nodes} node\n *   hast node.\n * @returns {boolean}\n *   Whether this represents a whole document or a fragment.\n */ function documentMode(node) {\n    const head = node.type === \"root\" ? node.children[0] : node;\n    return Boolean(head && (head.type === \"doctype\" || head.type === \"element\" && head.tagName === \"html\"));\n}\n/**\n * Get a `parse5` location from a node.\n *\n * @param {Nodes | Stitch} node\n *   hast node.\n * @returns {Location}\n *   `parse5` location.\n */ function createParse5Location(node) {\n    const start = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)(node) || {\n        line: undefined,\n        column: undefined,\n        offset: undefined\n    };\n    const end = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointEnd)(node) || {\n        line: undefined,\n        column: undefined,\n        offset: undefined\n    };\n    /** @type {Record<keyof Location, number | undefined>} */ const location = {\n        startLine: start.line,\n        startCol: start.column,\n        startOffset: start.offset,\n        endLine: end.line,\n        endCol: end.column,\n        endOffset: end.offset\n    };\n    // @ts-expect-error: unist point values can be `undefined` in hast, which\n    // `parse5` types donâ€™t want.\n    return location;\n}\n/**\n * @template {Nodes} NodeType\n *   Node type.\n * @param {NodeType} node\n *   Node to clone.\n * @returns {NodeType}\n *   Cloned node, without children.\n */ function cloneWithoutChildren(node) {\n    return \"children\" in node ? (0,_ungap_structured_clone__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ...node,\n        children: []\n    }) : (0,_ungap_structured_clone__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXJhdy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F5QkMsR0FFb0Q7QUFDTDtBQUNKO0FBQ087QUFDTTtBQUNEO0FBQ2xCO0FBQ007QUFDZjtBQUU3QixrQ0FBa0M7QUFDbEMsOEVBQThFO0FBQzlFLE1BQU1hLGdCQUFnQixJQUFJQyxJQUFJO0lBQzVCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELDBCQUEwQixHQUMxQixNQUFNQyxlQUFlO0lBQUNDLHdCQUF3QjtJQUFNQyxrQkFBa0I7QUFBSztBQUUzRTs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU0MsSUFBSUMsSUFBSSxFQUFFQyxPQUFPO0lBQy9CLE1BQU1DLFdBQVdDLGFBQWFIO0lBQzlCLHFEQUFxRCxHQUNyRCxNQUFNSSxNQUFNWCw4Q0FBTUEsQ0FBQyxRQUFRO1FBQ3pCWSxVQUFVO1lBQUNDO1lBQU1DO1lBQVNDO1lBQU1DO1lBQVNDO1lBQVNYLEtBQUtZO1FBQVM7UUFDaEVDO0lBQ0Y7SUFFQSxrQkFBa0IsR0FDbEIsTUFBTUMsUUFBUTtRQUNaQyxRQUFRWixXQUNKLElBQUlqQiwwQ0FBTUEsQ0FBQ1csZ0JBQ1hYLDBDQUFNQSxDQUFDOEIsaUJBQWlCLENBQUNDLFdBQVdwQjtRQUN4Q3FCLFFBQU9DLElBQUk7WUFDVGQsSUFBSWMsTUFBTUw7UUFDWjtRQUNBTSxVQUFVO1FBQ1ZsQixTQUFTQSxXQUFXLENBQUM7SUFDdkI7SUFFQUcsSUFBSUosTUFBTWE7SUFDVk8sZUFBZVAsT0FBT3ZCLCtEQUFVQTtJQUVoQyxNQUFNK0IsS0FBS25CLFdBQVdXLE1BQU1DLE1BQU0sQ0FBQ1osUUFBUSxHQUFHVyxNQUFNQyxNQUFNLENBQUNRLFdBQVc7SUFDdEUsTUFBTUMsU0FBU3pDLGlFQUFVQSxDQUFDdUMsSUFBSTtR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LEdBQ0QsU0FBUzlELHFCQUFxQnhCLElBQUk7SUFDaEMsTUFBTXdHLFFBQVFwSSwrREFBVUEsQ0FBQzRCLFNBQVM7UUFDaEM2RCxNQUFNL0Q7UUFDTitFLFFBQVEvRTtRQUNSbUUsUUFBUW5FO0lBQ1Y7SUFDQSxNQUFNMkcsTUFBTXRJLDZEQUFRQSxDQUFDNkIsU0FBUztRQUM1QjZELE1BQU0vRDtRQUNOK0UsUUFBUS9FO1FBQ1JtRSxRQUFRbkU7SUFDVjtJQUVBLHVEQUF1RCxHQUN2RCxNQUFNeUIsV0FBVztRQUNmb0QsV0FBVzZCLE1BQU0zQyxJQUFJO1FBQ3JCZSxVQUFVNEIsTUFBTTNCLE1BQU07UUFDdEJDLGFBQWEwQixNQUFNdkMsTUFBTTtRQUN6QkwsU0FBUzZDLElBQUk1QyxJQUFJO1FBQ2pCQyxRQUFRMkMsSUFBSTVCLE1BQU07UUFDbEJiLFdBQVd5QyxJQUFJeEMsTUFBTTtJQUN2QjtJQUVBLHlFQUF5RTtJQUN6RSw2QkFBNkI7SUFDN0IsT0FBTzFDO0FBQ1Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1UscUJBQXFCakMsSUFBSTtJQUNoQyxPQUFPLGNBQWNBLE9BQ2pCckMsbUVBQWVBLENBQUM7UUFBQyxHQUFHcUMsSUFBSTtRQUFFWSxVQUFVLEVBQUU7SUFBQSxLQUN0Q2pELG1FQUFlQSxDQUFDcUM7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Z3B0LWxpdGUvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXJhdy9saWIvaW5kZXguanM/MDNmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Db21tZW50fSBDb21tZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuRG9jdHlwZX0gRG9jdHlwZVxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLkVsZW1lbnR9IEVsZW1lbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Ob2Rlc30gTm9kZXNcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Sb290fSBSb290XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuUm9vdENvbnRlbnR9IFJvb3RDb250ZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuVGV4dH0gVGV4dFxuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ21kYXN0LXV0aWwtdG8taGFzdCcpLlJhd30gUmF3XG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuRGVmYXVsdFRyZWVBZGFwdGVyTWFwfSBEZWZhdWx0VHJlZUFkYXB0ZXJNYXBcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3BhcnNlNScpLlBhcnNlck9wdGlvbnM8RGVmYXVsdFRyZWVBZGFwdGVyTWFwPn0gUGFyc2VyT3B0aW9uc1xuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuVG9rZW4uQ2hhcmFjdGVyVG9rZW59IENoYXJhY3RlclRva2VuXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdwYXJzZTUnKS5Ub2tlbi5Db21tZW50VG9rZW59IENvbW1lbnRUb2tlblxuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuVG9rZW4uRG9jdHlwZVRva2VufSBEb2N0eXBlVG9rZW5cbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3BhcnNlNScpLlRva2VuLkxvY2F0aW9ufSBMb2NhdGlvblxuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuVG9rZW4uVGFnVG9rZW59IFRhZ1Rva2VuXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgndW5pc3QnKS5Qb2ludH0gUG9pbnRcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd2ZmlsZScpLlZGaWxlfSBWRmlsZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgT3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtWRmlsZSB8IG51bGwgfCB1bmRlZmluZWR9IFtmaWxlXVxuICogICBDb3JyZXNwb25kaW5nIHZpcnR1YWwgZmlsZSByZXByZXNlbnRpbmcgdGhlIGlucHV0IGRvY3VtZW50IChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0FycmF5PE5vZGVzWyd0eXBlJ10+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Bhc3NUaHJvdWdoXVxuICogICBMaXN0IG9mIGN1c3RvbSBoYXN0IG5vZGUgdHlwZXMgdG8gcGFzcyB0aHJvdWdoIChhcyBpbiwga2VlcCkgKG9wdGlvbmFsKS5cbiAqXG4gKiAgIElmIHRoZSBwYXNzZWQgdGhyb3VnaCBub2RlcyBoYXZlIGNoaWxkcmVuLCB0aG9zZSBjaGlsZHJlbiBhcmUgZXhwZWN0ZWQgdG9cbiAqICAgYmUgaGFzdCBhZ2FpbiBhbmQgd2lsbCBiZSBoYW5kbGVkLlxuICpcbiAqIEB0eXBlZGVmIFN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEBwcm9wZXJ0eSB7KG5vZGU6IE5vZGVzKSA9PiB1bmRlZmluZWR9IGhhbmRsZVxuICogICBBZGQgYSBoYXN0IG5vZGUgdG8gdGhlIHBhcnNlci5cbiAqIEBwcm9wZXJ0eSB7T3B0aW9uc30gb3B0aW9uc1xuICogICBVc2VyIGNvbmZpZ3VyYXRpb24uXG4gKiBAcHJvcGVydHkge1BhcnNlcjxEZWZhdWx0VHJlZUFkYXB0ZXJNYXA+fSBwYXJzZXJcbiAqICAgQ3VycmVudCBwYXJzZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0aXRjaGVzXG4gKiAgIFdoZXRoZXIgdGhlcmUgYXJlIHN0aXRjaGVzLlxuICpcbiAqIEB0eXBlZGVmIHt7dHlwZTogJ2NvbW1lbnQnLCB2YWx1ZToge3N0aXRjaDogTm9kZXN9fX0gU3RpdGNoXG4gKiAgIEN1c3RvbSBjb21tZW50LWxpa2UgdmFsdWUgd2UgcGFzcyB0aHJvdWdoIHBhcnNlNSwgd2hpY2ggY29udGFpbnMgYVxuICogICByZXBsYWNlbWVudCBub2RlIHRoYXQgd2XigJlsbCBzd2FwIGJhY2sgaW4gYWZ0ZXJ3YXJkcy5cbiAqL1xuXG5pbXBvcnQgc3RydWN0dXJlZENsb25lIGZyb20gJ0B1bmdhcC9zdHJ1Y3R1cmVkLWNsb25lJ1xuaW1wb3J0IHtmcm9tUGFyc2U1fSBmcm9tICdoYXN0LXV0aWwtZnJvbS1wYXJzZTUnXG5pbXBvcnQge3RvUGFyc2U1fSBmcm9tICdoYXN0LXV0aWwtdG8tcGFyc2U1J1xuaW1wb3J0IHtodG1sVm9pZEVsZW1lbnRzfSBmcm9tICdodG1sLXZvaWQtZWxlbWVudHMnXG5pbXBvcnQge1BhcnNlciwgVG9rZW4sIFRva2VuaXplck1vZGUsIGh0bWx9IGZyb20gJ3BhcnNlNSdcbmltcG9ydCB7cG9pbnRFbmQsIHBvaW50U3RhcnR9IGZyb20gJ3VuaXN0LXV0aWwtcG9zaXRpb24nXG5pbXBvcnQge3Zpc2l0fSBmcm9tICd1bmlzdC11dGlsLXZpc2l0J1xuaW1wb3J0IHt3ZWJOYW1lc3BhY2VzfSBmcm9tICd3ZWItbmFtZXNwYWNlcydcbmltcG9ydCB7endpdGNofSBmcm9tICd6d2l0Y2gnXG5cbi8vIE5vZGUgdHlwZXMgYXNzb2NpYXRlZCB3aXRoIE1EWC5cbi8vIDxodHRwczovL2dpdGh1Yi5jb20vbWR4LWpzL21keC9ibG9iLzhhNTYzMTIvcGFja2FnZXMvbWR4L2xpYi9ub2RlLXR5cGVzLmpzPlxuY29uc3Qga25vd25NZHhOYW1lcyA9IG5ldyBTZXQoW1xuICAnbWR4Rmxvd0V4cHJlc3Npb24nLFxuICAnbWR4SnN4Rmxvd0VsZW1lbnQnLFxuICAnbWR4SnN4VGV4dEVsZW1lbnQnLFxuICAnbWR4VGV4dEV4cHJlc3Npb24nLFxuICAnbWR4anNFc20nXG5dKVxuXG4vKiogQHR5cGUge1BhcnNlck9wdGlvbnN9ICovXG5jb25zdCBwYXJzZU9wdGlvbnMgPSB7c291cmNlQ29kZUxvY2F0aW9uSW5mbzogdHJ1ZSwgc2NyaXB0aW5nRW5hYmxlZDogZmFsc2V9XG5cbi8qKlxuICogUGFzcyBhIGhhc3QgdHJlZSB0aHJvdWdoIGFuIEhUTUwgcGFyc2VyLCB3aGljaCB3aWxsIGZpeCBuZXN0aW5nLCBhbmQgdHVyblxuICogcmF3IG5vZGVzIGludG8gYWN0dWFsIG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IHRyZWVcbiAqICAgT3JpZ2luYWwgaGFzdCB0cmVlIHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7T3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXVxuICogICBDb25maWd1cmF0aW9uIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7Tm9kZXN9XG4gKiAgIFBhcnNlZCBhZ2FpbiB0cmVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmF3KHRyZWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZG9jdW1lbnQgPSBkb2N1bWVudE1vZGUodHJlZSlcbiAgLyoqIEB0eXBlIHsobm9kZTogTm9kZXMsIHN0YXRlOiBTdGF0ZSkgPT4gdW5kZWZpbmVkfSAqL1xuICBjb25zdCBvbmUgPSB6d2l0Y2goJ3R5cGUnLCB7XG4gICAgaGFuZGxlcnM6IHtyb290LCBlbGVtZW50LCB0ZXh0LCBjb21tZW50LCBkb2N0eXBlLCByYXc6IGhhbmRsZVJhd30sXG4gICAgdW5rbm93blxuICB9KVxuXG4gIC8qKiBAdHlwZSB7U3RhdGV9ICovXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIHBhcnNlcjogZG9jdW1lbnRcbiAgICAgID8gbmV3IFBhcnNlcihwYXJzZU9wdGlvbnMpXG4gICAgICA6IFBhcnNlci5nZXRGcmFnbWVudFBhcnNlcih1bmRlZmluZWQsIHBhcnNlT3B0aW9ucyksXG4gICAgaGFuZGxlKG5vZGUpIHtcbiAgICAgIG9uZShub2RlLCBzdGF0ZSlcbiAgICB9LFxuICAgIHN0aXRjaGVzOiBmYWxzZSxcbiAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XG4gIH1cblxuICBvbmUodHJlZSwgc3RhdGUpXG4gIHJlc2V0VG9rZW5pemVyKHN0YXRlLCBwb2ludFN0YXJ0KCkpXG5cbiAgY29uc3QgcDUgPSBkb2N1bWVudCA/IHN0YXRlLnBhcnNlci5kb2N1bWVudCA6IHN0YXRlLnBhcnNlci5nZXRGcmFnbWVudCgpXG4gIGNvbnN0IHJlc3VsdCA9IGZyb21QYXJzZTUocDUsIHtcbiAgICAvLyBUbyBkbzogc3VwcG9ydCBgc3BhY2VgP1xuICAgIGZpbGU6IHN0YXRlLm9wdGlvbnMuZmlsZVxuICB9KVxuXG4gIGlmIChzdGF0ZS5zdGl0Y2hlcykge1xuICAgIHZpc2l0KHJlc3VsdCwgJ2NvbW1lbnQnLCBmdW5jdGlvbiAobm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICAgICAgY29uc3Qgc3RpdGNoID0gLyoqIEB0eXBlIHtTdGl0Y2h9ICovICgvKiogQHR5cGUge3Vua25vd259ICovIChub2RlKSlcbiAgICAgIGlmIChzdGl0Y2gudmFsdWUuc3RpdGNoICYmIHBhcmVudCAmJiBpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8Um9vdENvbnRlbnQ+fSAqL1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhc3N1bWUgdGhlIHN0aXRjaCBpcyBhbGxvd2VkLlxuICAgICAgICBzaWJsaW5nc1tpbmRleF0gPSBzdGl0Y2gudmFsdWUuc3RpdGNoXG4gICAgICAgIHJldHVybiBpbmRleFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBVbnBhY2sgaWYgcG9zc2libGUgYW5kIHdoZW4gbm90IGdpdmVuIGEgYHJvb3RgLlxuICBpZiAoXG4gICAgcmVzdWx0LnR5cGUgPT09ICdyb290JyAmJlxuICAgIHJlc3VsdC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICByZXN1bHQuY2hpbGRyZW5bMF0udHlwZSA9PT0gdHJlZS50eXBlXG4gICkge1xuICAgIHJldHVybiByZXN1bHQuY2hpbGRyZW5bMF1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYWxsIG5vZGVzXG4gKlxuICogQHBhcmFtIHtBcnJheTxSb290Q29udGVudD59IG5vZGVzXG4gKiAgIGhhc3QgY29udGVudC5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGFsbChub2Rlcywgc3RhdGUpIHtcbiAgbGV0IGluZGV4ID0gLTFcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIGludmFsaWQgbm9kZXMsIHNlZSByZWh5cGVqcy9yZWh5cGUtcmF3IzcuICovXG4gIGlmIChub2Rlcykge1xuICAgIHdoaWxlICgrK2luZGV4IDwgbm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5oYW5kbGUobm9kZXNbaW5kZXhdKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHJvb3QuXG4gKlxuICogQHBhcmFtIHtSb290fSBub2RlXG4gKiAgIGhhc3Qgcm9vdCBub2RlLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gcm9vdChub2RlLCBzdGF0ZSkge1xuICBhbGwobm9kZS5jaGlsZHJlbiwgc3RhdGUpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiAgIGhhc3QgZWxlbWVudCBub2RlLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gZWxlbWVudChub2RlLCBzdGF0ZSkge1xuICBzdGFydFRhZyhub2RlLCBzdGF0ZSlcblxuICBhbGwobm9kZS5jaGlsZHJlbiwgc3RhdGUpXG5cbiAgZW5kVGFnKG5vZGUsIHN0YXRlKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHRleHQuXG4gKlxuICogQHBhcmFtIHtUZXh0fSBub2RlXG4gKiAgIGhhc3QgdGV4dCBub2RlLlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gdGV4dChub2RlLCBzdGF0ZSkge1xuICAvKiogQHR5cGUge0NoYXJhY3RlclRva2VufSAqL1xuICBjb25zdCB0b2tlbiA9IHtcbiAgICB0eXBlOiBUb2tlbi5Ub2tlblR5cGUuQ0hBUkFDVEVSLFxuICAgIGNoYXJzOiBub2RlLnZhbHVlLFxuICAgIGxvY2F0aW9uOiBjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKVxuICB9XG5cbiAgcmVzZXRUb2tlbml6ZXIoc3RhdGUsIHBvaW50U3RhcnQobm9kZSkpXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIuY3VycmVudFRva2VuID0gdG9rZW5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci5fcHJvY2Vzc1Rva2VuKHN0YXRlLnBhcnNlci5jdXJyZW50VG9rZW4pXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgZG9jdHlwZS5cbiAqXG4gKiBAcGFyYW0ge0RvY3R5cGV9IG5vZGVcbiAqICAgaGFzdCBkb2N0eXBlIG5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBkb2N0eXBlKG5vZGUsIHN0YXRlKSB7XG4gIC8qKiBAdHlwZSB7RG9jdHlwZVRva2VufSAqL1xuICBjb25zdCB0b2tlbiA9IHtcbiAgICB0eXBlOiBUb2tlbi5Ub2tlblR5cGUuRE9DVFlQRSxcbiAgICBuYW1lOiAnaHRtbCcsXG4gICAgZm9yY2VRdWlya3M6IGZhbHNlLFxuICAgIHB1YmxpY0lkOiAnJyxcbiAgICBzeXN0ZW1JZDogJycsXG4gICAgbG9jYXRpb246IGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpXG4gIH1cblxuICByZXNldFRva2VuaXplcihzdGF0ZSwgcG9pbnRTdGFydChub2RlKSlcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci5jdXJyZW50VG9rZW4gPSB0b2tlblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLl9wcm9jZXNzVG9rZW4oc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbilcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBzdGl0Y2guXG4gKlxuICogQHBhcmFtIHtOb2Rlc30gbm9kZVxuICogICB1bmtub3duIG5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBzdGl0Y2gobm9kZSwgc3RhdGUpIHtcbiAgLy8gTWFyayB0aGF0IHRoZXJlIGFyZSBzdGl0Y2hlcywgc28gd2UgbmVlZCB0byB3YWxrIHRoZSB0cmVlIGFuZCByZXZlcnQgdGhlbS5cbiAgc3RhdGUuc3RpdGNoZXMgPSB0cnVlXG5cbiAgLyoqIEB0eXBlIHtOb2Rlc30gKi9cbiAgY29uc3QgY2xvbmUgPSBjbG9uZVdpdGhvdXRDaGlsZHJlbihub2RlKVxuXG4gIC8vIFJlY3Vyc2UsIGJlY2F1c2UgdG8gc29tZXdoYXQgaGFuZGxlIGBbPHg+XTwveD5gICh3aGVyZSBgW11gIGRlbm90ZXMgdGhlXG4gIC8vIHBhc3NlZCB0aHJvdWdoIG5vZGUpLlxuICBpZiAoJ2NoaWxkcmVuJyBpbiBub2RlICYmICdjaGlsZHJlbicgaW4gY2xvbmUpIHtcbiAgICAvLyBSb290IGluIHJvb3Qgb3V0LlxuICAgIGNvbnN0IGZha2VSb290ID0gLyoqIEB0eXBlIHtSb290fSAqLyAoXG4gICAgICByYXcoe3R5cGU6ICdyb290JywgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW59LCBzdGF0ZS5vcHRpb25zKVxuICAgIClcbiAgICBjbG9uZS5jaGlsZHJlbiA9IGZha2VSb290LmNoaWxkcmVuXG4gIH1cblxuICAvLyBIYWNrOiBgdmFsdWVgIGlzIHN1cHBvc2VkIHRvIGJlIGEgc3RyaW5nLCBidXQgYXMgbm9uZSBvZiB0aGUgdG9vbHNcbiAgLy8gKGBwYXJzZTVgIG9yIGBoYXN0LXV0aWwtZnJvbS1wYXJzZTVgKSBsb29rcyBhdCBpdCwgd2UgY2FuIHBhc3Mgbm9kZXNcbiAgLy8gdGhyb3VnaC5cbiAgY29tbWVudCh7dHlwZTogJ2NvbW1lbnQnLCB2YWx1ZToge3N0aXRjaDogY2xvbmV9fSwgc3RhdGUpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgY29tbWVudCAob3Igc3RpdGNoKS5cbiAqXG4gKiBAcGFyYW0ge0NvbW1lbnQgfCBTdGl0Y2h9IG5vZGVcbiAqICAgaGFzdCBjb21tZW50IG5vZGUuXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQgYWJvdXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBjb21tZW50KG5vZGUsIHN0YXRlKSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBwYXNzIHN0aXRjaGVzIHRocm91Z2guXG4gIGNvbnN0IGRhdGEgPSBub2RlLnZhbHVlXG5cbiAgLyoqIEB0eXBlIHtDb21tZW50VG9rZW59ICovXG4gIGNvbnN0IHRva2VuID0ge1xuICAgIHR5cGU6IFRva2VuLlRva2VuVHlwZS5DT01NRU5ULFxuICAgIGRhdGEsXG4gICAgbG9jYXRpb246IGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpXG4gIH1cbiAgcmVzZXRUb2tlbml6ZXIoc3RhdGUsIHBvaW50U3RhcnQobm9kZSkpXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIuY3VycmVudFRva2VuID0gdG9rZW5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci5fcHJvY2Vzc1Rva2VuKHN0YXRlLnBhcnNlci5jdXJyZW50VG9rZW4pXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcmF3IG5vZGUuXG4gKlxuICogQHBhcmFtIHtSYXd9IG5vZGVcbiAqICAgaGFzdCByYXcgbm9kZS5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVJhdyhub2RlLCBzdGF0ZSkge1xuICAvLyBSZXNldCBwcmVwcm9jZXNzb3I6XG4gIC8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmlrdWxpbi9wYXJzZTUvYmxvYi82ZjdjYTYwL3BhY2thZ2VzL3BhcnNlNS9saWIvdG9rZW5pemVyL3ByZXByb2Nlc3Nvci50cyNMMTgtTDMxPi5cbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IuaHRtbCA9ICcnXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5wb3MgPSAtMVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IubGFzdEdhcFBvcyA9IC0yXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5nYXBTdGFjayA9IFtdXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5za2lwTmV4dE5ld0xpbmUgPSBmYWxzZVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IubGFzdENodW5rV3JpdHRlbiA9IGZhbHNlXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIucHJlcHJvY2Vzc29yLmVuZE9mQ2h1bmtIaXQgPSBmYWxzZVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IuaXNFb2wgPSBmYWxzZVxuXG4gIC8vIE5vdyBwYXNzIGBub2RlLnZhbHVlYC5cbiAgc2V0UG9pbnQoc3RhdGUsIHBvaW50U3RhcnQobm9kZSkpXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIud3JpdGUobm9kZS52YWx1ZSwgZmFsc2UpXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLl9ydW5QYXJzaW5nTG9vcCgpXG5cbiAgLy8gQ2hhcmFjdGVyIHJlZmVyZW5jZXMgaGFuZywgc28gaWYgd2UgZW5kZWQgdGhlcmUsIHdlIG5lZWQgdG8gZmx1c2hcbiAgLy8gdGhvc2UgdG9vLlxuICAvLyBXZSByZXNldCB0aGUgcHJlcHJvY2Vzc29yIGFzIGlmIHRoZSBkb2N1bWVudCBlbmRzIGhlcmUuXG4gIC8vIFRoZW4gb25lIHNpbmdsZSBjYWxsIHRvIHRoZSByZWxldmFudCBzdGF0ZSBkb2VzIHRoZSB0cmljaywgcGFyc2U1XG4gIC8vIGNvbnN1bWVzIHRoZSB3aG9sZSB0b2tlbi5cblxuICAvLyBOb3RlOiBgU3RhdGVgIGlzIG5vdCBleHBvc2VkIGJ5IGBwYXJzZTVgLCBzbyB0aGVzZSBudW1iZXJzIGFyZSBmcmFnaWxlLlxuICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2Jsb2IvNDZjYmE0My9wYWNrYWdlcy9wYXJzZTUvbGliL3Rva2VuaXplci9pbmRleC50cyNMNTg+XG4gIC8vIE5vdGU6IGEgY2hhbmdlIHRvIGBwYXJzZTVgLCB3aGljaCBicmVha3MgdGhpcywgd2FzIG1lcmdlZCBidXQgbm90IHJlbGVhc2VkLlxuICAvLyBJbnZlc3RpZ2F0ZSB3aGVuIGl0IGlzLlxuICBpZiAoXG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5zdGF0ZSA9PT0gNzIgLyogTkFNRURfQ0hBUkFDVEVSX1JFRkVSRU5DRSAqLyB8fFxuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPT09IDc4IC8qIE5VTUVSSUNfQ0hBUkFDVEVSX1JFRkVSRU5DRV9FTkQgKi9cbiAgKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5sYXN0Q2h1bmtXcml0dGVuID0gdHJ1ZVxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gICAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gICAgY29uc3QgY3AgPSBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLl9jb25zdW1lKClcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuX2NhbGxTdGF0ZShjcClcbiAgfVxufVxuXG4vKipcbiAqIENyYXNoIG9uIGFuIHVua25vd24gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IG5vZGVfXG4gKiAgIHVua25vd24gbm9kZS5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5ldmVyLlxuICovXG5mdW5jdGlvbiB1bmtub3duKG5vZGVfLCBzdGF0ZSkge1xuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtOb2Rlc30gKi8gKG5vZGVfKVxuXG4gIGlmIChcbiAgICBzdGF0ZS5vcHRpb25zLnBhc3NUaHJvdWdoICYmXG4gICAgc3RhdGUub3B0aW9ucy5wYXNzVGhyb3VnaC5pbmNsdWRlcyhub2RlLnR5cGUpXG4gICkge1xuICAgIHN0aXRjaChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICBsZXQgZXh0cmEgPSAnJ1xuXG4gICAgaWYgKGtub3duTWR4TmFtZXMuaGFzKG5vZGUudHlwZSkpIHtcbiAgICAgIGV4dHJhID1cbiAgICAgICAgXCIuIEl0IGxvb2tzIGxpa2UgeW91IGFyZSB1c2luZyBNRFggbm9kZXMgd2l0aCBgaGFzdC11dGlsLXJhd2AgKG9yIGByZWh5cGUtcmF3YCkuIElmIHlvdSB1c2UgdGhpcyBiZWNhdXNlIHlvdSBhcmUgdXNpbmcgcmVtYXJrIG9yIHJlaHlwZSBwbHVnaW5zIHRoYXQgaW5qZWN0IGAnaHRtbCdgIG5vZGVzLCB0aGVuIHBsZWFzZSByYWlzZSBhbiBpc3N1ZSB3aXRoIHRoYXQgcGx1Z2luLCBhcyBpdHMgYSBiYWQgYW5kIHNsb3cgaWRlYS4gSWYgeW91IHVzZSB0aGlzIGJlY2F1c2UgeW91IGFyZSB1c2luZyBtYXJrZG93biBzeW50YXgsIHRoZW4geW91IGhhdmUgdG8gY29uZmlndXJlIHRoaXMgdXRpbGl0eSAob3IgcGx1Z2luKSB0byBwYXNzIHRocm91Z2ggdGhlc2Ugbm9kZXMgKHNlZSBgcGFzc1Rocm91Z2hgIGluIGRvY3MpLCBidXQgeW91IGNhbiBhbHNvIG1pZ3JhdGUgdG8gdXNlIHRoZSBNRFggc3ludGF4XCJcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21waWxlIGAnICsgbm9kZS50eXBlICsgJ2Agbm9kZScgKyBleHRyYSlcbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0IHRoZSB0b2tlbml6ZXIgb2YgYSBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHtQb2ludCB8IHVuZGVmaW5lZH0gcG9pbnRcbiAqICAgUG9pbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogICBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiByZXNldFRva2VuaXplcihzdGF0ZSwgcG9pbnQpIHtcbiAgc2V0UG9pbnQoc3RhdGUsIHBvaW50KVxuXG4gIC8vIFByb2Nlc3MgZmluYWwgY2hhcmFjdGVycyBpZiB0aGV54oCZcmUgc3RpbGwgdGhlcmUgYWZ0ZXIgaGliZXJuYXRpbmcuXG4gIC8qKiBAdHlwZSB7Q2hhcmFjdGVyVG9rZW59ICovXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBjb25zdCB0b2tlbiA9IHN0YXRlLnBhcnNlci50b2tlbml6ZXIuY3VycmVudENoYXJhY3RlclRva2VuXG5cbiAgaWYgKHRva2VuICYmIHRva2VuLmxvY2F0aW9uKSB7XG4gICAgdG9rZW4ubG9jYXRpb24uZW5kTGluZSA9IHN0YXRlLnBhcnNlci50b2tlbml6ZXIucHJlcHJvY2Vzc29yLmxpbmVcbiAgICB0b2tlbi5sb2NhdGlvbi5lbmRDb2wgPSBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5jb2wgKyAxXG4gICAgdG9rZW4ubG9jYXRpb24uZW5kT2Zmc2V0ID0gc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3Iub2Zmc2V0ICsgMVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gICAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gICAgc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbiA9IHRva2VuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgICBzdGF0ZS5wYXJzZXIuX3Byb2Nlc3NUb2tlbihzdGF0ZS5wYXJzZXIuY3VycmVudFRva2VuKVxuICB9XG5cbiAgLy8gUmVzZXQgdG9rZW5pemVyOlxuICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2Jsb2IvNmY3Y2E2MC9wYWNrYWdlcy9wYXJzZTUvbGliL3Rva2VuaXplci9pbmRleC50cyNMMTg3LUwyMjM+LlxuICAvLyBFc3BlY2lhbGx5IHB1dHRpbmcgaXQgYmFjayBpbiB0aGUgYGRhdGFgIHN0YXRlIGlzIHVzZWZ1bDogc29tZSBlbGVtZW50cyxcbiAgLy8gbGlrZSB0ZXh0YXJlYXMgYW5kIGlmcmFtZXMsIGNoYW5nZSB0aGUgc3RhdGUuXG4gIC8vIFNlZSBHSC03LlxuICAvLyBCdXQgYWxzbyBpZiBicm9rZW4gSFRNTCBpcyBpbiBgcmF3YCwgYW5kIHRoZW4gYSBjb3JyZWN0IGVsZW1lbnQgaXMgZ2l2ZW4uXG4gIC8vIFNlZSBHSC0xMS5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIucGF1c2VkID0gZmFsc2VcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuaW5Mb29wID0gZmFsc2VcblxuICAvLyBOb3RlOiBkb27igJl0IHJlc2V0IGBzdGF0ZWAsIGBpbkZvcmVpZ25Ob2RlYCwgb3IgYGxhc3RTdGFydFRhZ05hbWVgLCB3ZVxuICAvLyBtYW51YWxseSB1cGRhdGUgdGhvc2Ugd2hlbiBuZWVkZWQuXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuYWN0aXZlID0gZmFsc2VcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIucmV0dXJuU3RhdGUgPSBUb2tlbml6ZXJNb2RlLkRBVEFcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuY2hhclJlZkNvZGUgPSAtMVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5jb25zdW1lZEFmdGVyU25hcHNob3QgPSAtMVxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5jdXJyZW50TG9jYXRpb24gPSBudWxsXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLmN1cnJlbnRDaGFyYWN0ZXJUb2tlbiA9IG51bGxcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogcHJpdmF0ZS5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuY3VycmVudFRva2VuID0gbnVsbFxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLnRva2VuaXplci5jdXJyZW50QXR0ciA9IHtuYW1lOiAnJywgdmFsdWU6ICcnfVxufVxuXG4vKipcbiAqIFNldCBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7UG9pbnQgfCB1bmRlZmluZWR9IHBvaW50XG4gKiAgIFBvaW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gc2V0UG9pbnQoc3RhdGUsIHBvaW50KSB7XG4gIGlmIChwb2ludCAmJiBwb2ludC5vZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8qKiBAdHlwZSB7TG9jYXRpb259ICovXG4gICAgY29uc3QgbG9jYXRpb24gPSB7XG4gICAgICBzdGFydExpbmU6IHBvaW50LmxpbmUsXG4gICAgICBzdGFydENvbDogcG9pbnQuY29sdW1uLFxuICAgICAgc3RhcnRPZmZzZXQ6IHBvaW50Lm9mZnNldCxcbiAgICAgIGVuZExpbmU6IC0xLFxuICAgICAgZW5kQ29sOiAtMSxcbiAgICAgIGVuZE9mZnNldDogLTFcbiAgICB9XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZXIucHJlcHJvY2Vzc29yLmxpbmVTdGFydFBvcyA9IC1wb2ludC5jb2x1bW4gKyAxIC8vIExvb2tzIHdlaXJkLCBidXQgZW5zdXJlcyB3ZSBnZXQgY29ycmVjdCBwb3NpdGlvbmFsIGluZm8uXG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5wcmVwcm9jZXNzb3IuZHJvcHBlZEJ1ZmZlclNpemUgPSBwb2ludC5vZmZzZXRcbiAgICBzdGF0ZS5wYXJzZXIudG9rZW5pemVyLnByZXByb2Nlc3Nvci5saW5lID0gcG9pbnQubGluZVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gICAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvblxuICB9XG59XG5cbi8qKlxuICogRW1pdCBhIHN0YXJ0IHRhZy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqICAgRWxlbWVudC5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZCBhYm91dCB0aGUgY3VycmVudCBzdGF0ZS5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiAgIE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0VGFnKG5vZGUsIHN0YXRlKSB7XG4gIC8vIElnbm9yZSB0YWdzIGlmIHdl4oCZcmUgaW4gcGxhaW4gdGV4dC5cbiAgaWYgKHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplck1vZGUuUExBSU5URVhUKSByZXR1cm5cblxuICByZXNldFRva2VuaXplcihzdGF0ZSwgcG9pbnRTdGFydChub2RlKSlcblxuICBjb25zdCBjdXJyZW50ID0gc3RhdGUucGFyc2VyLm9wZW5FbGVtZW50cy5jdXJyZW50XG4gIGxldCBucyA9ICduYW1lc3BhY2VVUkknIGluIGN1cnJlbnQgPyBjdXJyZW50Lm5hbWVzcGFjZVVSSSA6IHdlYk5hbWVzcGFjZXMuaHRtbFxuXG4gIGlmIChucyA9PT0gd2ViTmFtZXNwYWNlcy5odG1sICYmIG5vZGUudGFnTmFtZSA9PT0gJ3N2ZycpIHtcbiAgICBucyA9IHdlYk5hbWVzcGFjZXMuc3ZnXG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB0b1BhcnNlNShcbiAgICAvLyBTaGFsbG93IGNsb25lIHRvIG5vdCBkZWx2ZSBpbnRvIGBjaGlsZHJlbmA6IHdlIG9ubHkgbmVlZCB0aGUgYXR0cmlidXRlcy5cbiAgICB7Li4ubm9kZSwgY2hpbGRyZW46IFtdfSxcbiAgICB7c3BhY2U6IG5zID09PSB3ZWJOYW1lc3BhY2VzLnN2ZyA/ICdzdmcnIDogJ2h0bWwnfVxuICApXG4gIC8vIEFsd2F5cyBlbGVtZW50LlxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICBjb25zdCBhdHRycyA9ICdhdHRycycgaW4gcmVzdWx0ID8gcmVzdWx0LmF0dHJzIDogW11cblxuICAvKiogQHR5cGUge1RhZ1Rva2VufSAqL1xuICBjb25zdCB0YWcgPSB7XG4gICAgdHlwZTogVG9rZW4uVG9rZW5UeXBlLlNUQVJUX1RBRyxcbiAgICB0YWdOYW1lOiBub2RlLnRhZ05hbWUsXG4gICAgdGFnSUQ6IGh0bWwuZ2V0VGFnSUQobm9kZS50YWdOYW1lKSxcbiAgICAvLyBXZSBhbHdheXMgc2VuZCBzdGFydCBhbmQgZW5kIHRhZ3MuXG4gICAgc2VsZkNsb3Npbmc6IGZhbHNlLFxuICAgIGFja1NlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICBhdHRycyxcbiAgICBsb2NhdGlvbjogY3JlYXRlUGFyc2U1TG9jYXRpb24obm9kZSlcbiAgfVxuXG4gIC8vIFRoZSBIVE1MIHBhcnNpbmcgYWxnb3JpdGhtIHdvcmtzIGJ5IGRvaW5nIGhhbGYgb2YgdGhlIHN0YXRlIG1hbmFnZW1lbnQgaW5cbiAgLy8gdGhlIHRva2VuaXplciBhbmQgaGFsZiBpbiB0aGUgcGFyc2VyLlxuICAvLyBXZSBjYW7igJl0IHVzZSB0aGUgdG9rZW5pemVyIGhlcmUsIGFzIHdlIGRvbuKAmXQgaGF2ZSBzdHJpbmdzLlxuICAvLyBTbyB3ZSBhY3QgKmFzIGlmKiB0aGUgdG9rZW5pemVyIGVtaXRzIHRva2VuczpcblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbiA9IHRhZ1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBwcml2YXRlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgc3RhdGUucGFyc2VyLl9wcm9jZXNzVG9rZW4oc3RhdGUucGFyc2VyLmN1cnJlbnRUb2tlbilcblxuICAvLyDigKZidXQgdGhlbiB3ZSBzdGlsbCBuZWVkIGEgYnVuY2ggb2Ygd29yayB0aGF0IHRoZSB0b2tlbml6ZXIgd291bGQgbm9ybWFsbHlcbiAgLy8gZG8sIHN1Y2ggYXM6XG5cbiAgLy8gU2V0IGEgdGFnIG5hbWUsIHNpbWlsYXIgdG8gaG93IHRoZSB0b2tlbml6ZXIgd291bGQgZG8gaXQuXG4gIHN0YXRlLnBhcnNlci50b2tlbml6ZXIubGFzdFN0YXJ0VGFnTmFtZSA9IG5vZGUudGFnTmFtZVxuXG4gIC8vIGBpbkZvcmVpZ25Ob2RlYCBpcyBjb3JyZWN0bHkgc2V0IGJ5IHRoZSBwYXJzZXIuXG59XG5cbi8qKlxuICogRW1pdCBhbiBlbmQgdGFnLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogICBFbGVtZW50LlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kIGFib3V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqICAgTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gZW5kVGFnKG5vZGUsIHN0YXRlKSB7XG4gIC8vIERvIG5vdCBlbWl0IGNsb3NpbmcgdGFncyBmb3IgSFRNTCB2b2lkIGVsZW1lbnRzLlxuICBpZiAoXG4gICAgIXN0YXRlLnBhcnNlci50b2tlbml6ZXIuaW5Gb3JlaWduTm9kZSAmJlxuICAgIGh0bWxWb2lkRWxlbWVudHMuaW5jbHVkZXMobm9kZS50YWdOYW1lKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIElnbm9yZSB0YWdzIGlmIHdl4oCZcmUgaW4gcGxhaW4gdGV4dC5cbiAgaWYgKHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplck1vZGUuUExBSU5URVhUKSByZXR1cm5cblxuICByZXNldFRva2VuaXplcihzdGF0ZSwgcG9pbnRFbmQobm9kZSkpXG5cbiAgLyoqIEB0eXBlIHtUYWdUb2tlbn0gKi9cbiAgY29uc3QgdGFnID0ge1xuICAgIHR5cGU6IFRva2VuLlRva2VuVHlwZS5FTkRfVEFHLFxuICAgIHRhZ05hbWU6IG5vZGUudGFnTmFtZSxcbiAgICB0YWdJRDogaHRtbC5nZXRUYWdJRChub2RlLnRhZ05hbWUpLFxuICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICBhY2tTZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgYXR0cnM6IFtdLFxuICAgIGxvY2F0aW9uOiBjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKVxuICB9XG5cbiAgLy8gVGhlIEhUTUwgcGFyc2luZyBhbGdvcml0aG0gd29ya3MgYnkgZG9pbmcgaGFsZiBvZiB0aGUgc3RhdGUgbWFuYWdlbWVudCBpblxuICAvLyB0aGUgdG9rZW5pemVyIGFuZCBoYWxmIGluIHRoZSBwYXJzZXIuXG4gIC8vIFdlIGNhbuKAmXQgdXNlIHRoZSB0b2tlbml6ZXIgaGVyZSwgYXMgd2UgZG9u4oCZdCBoYXZlIHN0cmluZ3MuXG4gIC8vIFNvIHdlIGFjdCAqYXMgaWYqIHRoZSB0b2tlbml6ZXIgZW1pdHMgdG9rZW5zOlxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIuY3VycmVudFRva2VuID0gdGFnXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IHByaXZhdGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBzdGF0ZS5wYXJzZXIuX3Byb2Nlc3NUb2tlbihzdGF0ZS5wYXJzZXIuY3VycmVudFRva2VuKVxuXG4gIC8vIOKApmJ1dCB0aGVuIHdlIHN0aWxsIG5lZWQgYSBidW5jaCBvZiB3b3JrIHRoYXQgdGhlIHRva2VuaXplciB3b3VsZCBub3JtYWxseVxuICAvLyBkbywgc3VjaCBhczpcblxuICAvLyBTd2l0Y2ggYmFjayB0byB0aGUgZGF0YSBzdGF0ZSBhZnRlciBhbHRlcm5hdGl2ZSBzdGF0ZXMgdGhhdCBkb27igJl0IGFjY2VwdFxuICAvLyB0YWdzOlxuICBpZiAoXG4gICAgLy8gQ3VycmVudCBlbGVtZW50IGlzIGNsb3NlZC5cbiAgICB0YWcudGFnTmFtZSA9PT0gc3RhdGUucGFyc2VyLnRva2VuaXplci5sYXN0U3RhcnRUYWdOYW1lICYmXG4gICAgLy8gYDx0ZXh0YXJlYT5gIGFuZCBgPHRpdGxlPmBcbiAgICAoc3RhdGUucGFyc2VyLnRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyTW9kZS5SQ0RBVEEgfHxcbiAgICAgIC8vIGA8aWZyYW1lPmAsIGA8bm9lbWJlZD5gLCBgPHN0eWxlPmAsIGA8eG1wPmBcbiAgICAgIHN0YXRlLnBhcnNlci50b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplck1vZGUuUkFXVEVYVCB8fFxuICAgICAgLy8gYDxzY3JpcHQ+YFxuICAgICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyTW9kZS5TQ1JJUFRfREFUQSlcbiAgKSB7XG4gICAgc3RhdGUucGFyc2VyLnRva2VuaXplci5zdGF0ZSA9IFRva2VuaXplck1vZGUuREFUQVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYG5vZGVgIHJlcHJlc2VudHMgYSB3aG9sZSBkb2N1bWVudCBvciBhIGZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqICAgaGFzdCBub2RlLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiAgIFdoZXRoZXIgdGhpcyByZXByZXNlbnRzIGEgd2hvbGUgZG9jdW1lbnQgb3IgYSBmcmFnbWVudC5cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRNb2RlKG5vZGUpIHtcbiAgY29uc3QgaGVhZCA9IG5vZGUudHlwZSA9PT0gJ3Jvb3QnID8gbm9kZS5jaGlsZHJlblswXSA6IG5vZGVcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgaGVhZCAmJlxuICAgICAgKGhlYWQudHlwZSA9PT0gJ2RvY3R5cGUnIHx8XG4gICAgICAgIChoZWFkLnR5cGUgPT09ICdlbGVtZW50JyAmJiBoZWFkLnRhZ05hbWUgPT09ICdodG1sJykpXG4gIClcbn1cblxuLyoqXG4gKiBHZXQgYSBgcGFyc2U1YCBsb2NhdGlvbiBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge05vZGVzIHwgU3RpdGNofSBub2RlXG4gKiAgIGhhc3Qgbm9kZS5cbiAqIEByZXR1cm5zIHtMb2NhdGlvbn1cbiAqICAgYHBhcnNlNWAgbG9jYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpIHtcbiAgY29uc3Qgc3RhcnQgPSBwb2ludFN0YXJ0KG5vZGUpIHx8IHtcbiAgICBsaW5lOiB1bmRlZmluZWQsXG4gICAgY29sdW1uOiB1bmRlZmluZWQsXG4gICAgb2Zmc2V0OiB1bmRlZmluZWRcbiAgfVxuICBjb25zdCBlbmQgPSBwb2ludEVuZChub2RlKSB8fCB7XG4gICAgbGluZTogdW5kZWZpbmVkLFxuICAgIGNvbHVtbjogdW5kZWZpbmVkLFxuICAgIG9mZnNldDogdW5kZWZpbmVkXG4gIH1cblxuICAvKiogQHR5cGUge1JlY29yZDxrZXlvZiBMb2NhdGlvbiwgbnVtYmVyIHwgdW5kZWZpbmVkPn0gKi9cbiAgY29uc3QgbG9jYXRpb24gPSB7XG4gICAgc3RhcnRMaW5lOiBzdGFydC5saW5lLFxuICAgIHN0YXJ0Q29sOiBzdGFydC5jb2x1bW4sXG4gICAgc3RhcnRPZmZzZXQ6IHN0YXJ0Lm9mZnNldCxcbiAgICBlbmRMaW5lOiBlbmQubGluZSxcbiAgICBlbmRDb2w6IGVuZC5jb2x1bW4sXG4gICAgZW5kT2Zmc2V0OiBlbmQub2Zmc2V0XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiB1bmlzdCBwb2ludCB2YWx1ZXMgY2FuIGJlIGB1bmRlZmluZWRgIGluIGhhc3QsIHdoaWNoXG4gIC8vIGBwYXJzZTVgIHR5cGVzIGRvbuKAmXQgd2FudC5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2Rlc30gTm9kZVR5cGVcbiAqICAgTm9kZSB0eXBlLlxuICogQHBhcmFtIHtOb2RlVHlwZX0gbm9kZVxuICogICBOb2RlIHRvIGNsb25lLlxuICogQHJldHVybnMge05vZGVUeXBlfVxuICogICBDbG9uZWQgbm9kZSwgd2l0aG91dCBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY2xvbmVXaXRob3V0Q2hpbGRyZW4obm9kZSkge1xuICByZXR1cm4gJ2NoaWxkcmVuJyBpbiBub2RlXG4gICAgPyBzdHJ1Y3R1cmVkQ2xvbmUoey4uLm5vZGUsIGNoaWxkcmVuOiBbXX0pXG4gICAgOiBzdHJ1Y3R1cmVkQ2xvbmUobm9kZSlcbn1cbiJdLCJuYW1lcyI6WyJzdHJ1Y3R1cmVkQ2xvbmUiLCJmcm9tUGFyc2U1IiwidG9QYXJzZTUiLCJodG1sVm9pZEVsZW1lbnRzIiwiUGFyc2VyIiwiVG9rZW4iLCJUb2tlbml6ZXJNb2RlIiwiaHRtbCIsInBvaW50RW5kIiwicG9pbnRTdGFydCIsInZpc2l0Iiwid2ViTmFtZXNwYWNlcyIsInp3aXRjaCIsImtub3duTWR4TmFtZXMiLCJTZXQiLCJwYXJzZU9wdGlvbnMiLCJzb3VyY2VDb2RlTG9jYXRpb25JbmZvIiwic2NyaXB0aW5nRW5hYmxlZCIsInJhdyIsInRyZWUiLCJvcHRpb25zIiwiZG9jdW1lbnQiLCJkb2N1bWVudE1vZGUiLCJvbmUiLCJoYW5kbGVycyIsInJvb3QiLCJlbGVtZW50IiwidGV4dCIsImNvbW1lbnQiLCJkb2N0eXBlIiwiaGFuZGxlUmF3IiwidW5rbm93biIsInN0YXRlIiwicGFyc2VyIiwiZ2V0RnJhZ21lbnRQYXJzZXIiLCJ1bmRlZmluZWQiLCJoYW5kbGUiLCJub2RlIiwic3RpdGNoZXMiLCJyZXNldFRva2VuaXplciIsInA1IiwiZ2V0RnJhZ21lbnQiLCJyZXN1bHQiLCJmaWxlIiwiaW5kZXgiLCJwYXJlbnQiLCJzdGl0Y2giLCJ2YWx1ZSIsInNpYmxpbmdzIiwiY2hpbGRyZW4iLCJ0eXBlIiwibGVuZ3RoIiwiYWxsIiwibm9kZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsInRva2VuIiwiVG9rZW5UeXBlIiwiQ0hBUkFDVEVSIiwiY2hhcnMiLCJsb2NhdGlvbiIsImNyZWF0ZVBhcnNlNUxvY2F0aW9uIiwiY3VycmVudFRva2VuIiwiX3Byb2Nlc3NUb2tlbiIsIkRPQ1RZUEUiLCJuYW1lIiwiZm9yY2VRdWlya3MiLCJwdWJsaWNJZCIsInN5c3RlbUlkIiwiY2xvbmUiLCJjbG9uZVdpdGhvdXRDaGlsZHJlbiIsImZha2VSb290IiwiZGF0YSIsIkNPTU1FTlQiLCJ0b2tlbml6ZXIiLCJwcmVwcm9jZXNzb3IiLCJwb3MiLCJsYXN0R2FwUG9zIiwiZ2FwU3RhY2siLCJza2lwTmV4dE5ld0xpbmUiLCJsYXN0Q2h1bmtXcml0dGVuIiwiZW5kT2ZDaHVua0hpdCIsImlzRW9sIiwic2V0UG9pbnQiLCJ3cml0ZSIsIl9ydW5QYXJzaW5nTG9vcCIsImNwIiwiX2NvbnN1bWUiLCJfY2FsbFN0YXRlIiwibm9kZV8iLCJwYXNzVGhyb3VnaCIsImluY2x1ZGVzIiwiZXh0cmEiLCJoYXMiLCJFcnJvciIsInBvaW50IiwiY3VycmVudENoYXJhY3RlclRva2VuIiwiZW5kTGluZSIsImxpbmUiLCJlbmRDb2wiLCJjb2wiLCJlbmRPZmZzZXQiLCJvZmZzZXQiLCJwYXVzZWQiLCJpbkxvb3AiLCJhY3RpdmUiLCJyZXR1cm5TdGF0ZSIsIkRBVEEiLCJjaGFyUmVmQ29kZSIsImNvbnN1bWVkQWZ0ZXJTbmFwc2hvdCIsImN1cnJlbnRMb2NhdGlvbiIsImN1cnJlbnRBdHRyIiwic3RhcnRMaW5lIiwic3RhcnRDb2wiLCJjb2x1bW4iLCJzdGFydE9mZnNldCIsImxpbmVTdGFydFBvcyIsImRyb3BwZWRCdWZmZXJTaXplIiwiUExBSU5URVhUIiwiY3VycmVudCIsIm9wZW5FbGVtZW50cyIsIm5zIiwibmFtZXNwYWNlVVJJIiwidGFnTmFtZSIsInN2ZyIsInNwYWNlIiwiYXR0cnMiLCJ0YWciLCJTVEFSVF9UQUciLCJ0YWdJRCIsImdldFRhZ0lEIiwic2VsZkNsb3NpbmciLCJhY2tTZWxmQ2xvc2luZyIsImxhc3RTdGFydFRhZ05hbWUiLCJpbkZvcmVpZ25Ob2RlIiwiRU5EX1RBRyIsIlJDREFUQSIsIlJBV1RFWFQiLCJTQ1JJUFRfREFUQSIsImhlYWQiLCJCb29sZWFuIiwic3RhcnQiLCJlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-raw/lib/index.js\n");

/***/ })

};
;