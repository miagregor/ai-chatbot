"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-to-jsx-runtime";
exports.ids = ["vendor-chunks/hast-util-to-jsx-runtime"];
exports.modules = {

/***/ "(ssr)/./node_modules/hast-util-to-jsx-runtime/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/hast-util-to-jsx-runtime/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toJsxRuntime: () => (/* binding */ toJsxRuntime)\n/* harmony export */ });\n/* harmony import */ var comma_separated_tokens__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! comma-separated-tokens */ \"(ssr)/./node_modules/comma-separated-tokens/index.js\");\n/* harmony import */ var hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-whitespace */ \"(ssr)/./node_modules/hast-util-whitespace/lib/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/property-information/index.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/property-information/lib/find.js\");\n/* harmony import */ var property_information__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! property-information */ \"(ssr)/./node_modules/property-information/lib/hast-to-react.js\");\n/* harmony import */ var space_separated_tokens__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! space-separated-tokens */ \"(ssr)/./node_modules/space-separated-tokens/index.js\");\n/* harmony import */ var style_to_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-to-object */ \"(ssr)/./node_modules/style-to-object/index.mjs\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-position */ \"(ssr)/./node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vfile-message */ \"(ssr)/./node_modules/vfile-message/lib/index.js\");\n/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('./components.js').Components} Components\n */ /**\n * @typedef {JSX.Element | string | null | undefined} Child\n *   Child.\n *\n * @callback Create\n *   Create something in development or production.\n * @param {Nodes} node\n *   hast node.\n * @param {unknown} type\n *   Fragment symbol or tag name.\n * @param {Props} props\n *   Properties and children.\n * @param {string | undefined} key\n *   Key.\n * @returns {JSX.Element}\n *   Result.\n *\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @typedef {[string, Value]} Field\n *   Property field.\n *\n * @typedef {unknown} Fragment\n *   Represent the children, typically a symbol.\n *\n * @callback Jsx\n *   Create a production element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} [key]\n *   Dynamicly generated key to use.\n * @returns {JSX.Element}\n *   An element from your framework.\n *\n * @callback JsxDev\n *   Create a development element.\n * @param {unknown} type\n *   Element type: `Fragment` symbol, tag name (`string`), component.\n * @param {Props} props\n *   Element props, `children`, and maybe `node`.\n * @param {string | undefined} key\n *   Dynamicly generated key to use.\n * @param {boolean} isStaticChildren\n *   Whether two or more children are passed (in an array), which is whether\n *   `jsxs` or `jsx` would be used.\n * @param {Source} source\n *   Info about source.\n * @param {undefined} self\n *   Nothing (this is used by frameworks that have components, we donâ€™t).\n * @returns {JSX.Element}\n *   An element from your framework.\n *\n * @typedef {{children?: Array<Child> | Child, node?: Element | undefined, [prop: string]: Array<Child> | Child | Element | Value | undefined}} Props\n *   Properties and children.\n *\n * @typedef RegularFields\n *   Configuration.\n * @property {Partial<Components> | null | undefined} [components]\n *   Components to use (optional).\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names (default: `'react'`).\n * @property {string | null | undefined} [filePath]\n *   File path to the original source file (optional).\n *\n *   Passed in source info to `jsxDEV` when using the automatic runtime with\n *   `development: true`.\n * @property {boolean | null | undefined} [ignoreInvalidStyle=false]\n *   Ignore invalid CSS in `style` props (default: `false`);\n *   the default behavior is to throw an error.\n * @property {boolean | null | undefined} [passKeys=true]\n *   Generate keys to optimize frameworks that support them (default: `true`).\n *\n *   > ðŸ‘‰ **Note**: Solid currently fails if keys are passed.\n * @property {boolean | null | undefined} [passNode=false]\n *   Pass the hast element node to components (default: `false`).\n * @property {Space | null | undefined} [space='html']\n *   Whether `tree` is in the `'html'` or `'svg'` space (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects (default:\n *   `'dom'`).\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\n *   (default: `true`).\n *\n * @typedef RuntimeDevelopment\n *   Runtime fields when development is on.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {true} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev} jsxDEV\n *   Development JSX.\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef RuntimeProduction\n *   Runtime fields when development is off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {false | null | undefined} [development]\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off) (optional).\n * @property {Jsx} jsx\n *   Dynamic JSX.\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx} jsxs\n *   Static JSX.\n *\n * @typedef RuntimeUnknown\n *   Runtime fields when development might be on or off.\n * @property {Fragment} Fragment\n *   Fragment.\n * @property {boolean} development\n *   Whether to use `jsxDEV` (when on) or `jsx` and `jsxs` (when off).\n * @property {Jsx | null | undefined} [jsx]\n *   Dynamic JSX (optional).\n * @property {JsxDev | null | undefined} [jsxDEV]\n *   Development JSX (optional).\n * @property {Jsx | null | undefined} [jsxs]\n *   Static JSX (optional).\n *\n * @typedef Source\n *   Info about source.\n * @property {number | undefined} columnNumber\n *   Column where thing starts (0-indexed).\n * @property {string | undefined} fileName\n *   Name of source file.\n * @property {number | undefined} lineNumber\n *   Line where thing starts (1-indexed).\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n *   > ðŸ‘‰ **Note**: hast is not XML.\n *   > It supports SVG as embedded in HTML.\n *   > It does not support the features available in XML.\n *   > Passing SVG might break but fragments of modern SVG should be fine.\n *   > Use `xast` if you need to support SVG as XML.\n *\n * @typedef State\n *   Info passed around.\n * @property {unknown} Fragment\n *   Fragment symbol.\n * @property {Array<Parents>} ancestors\n *   Stack of parents.\n * @property {Partial<Components>} components\n *   Components to swap.\n * @property {Create} create\n *   Create something in development or production.\n * @property {ElementAttributeNameCase} elementAttributeNameCase\n *   Casing to use for attribute names.\n * @property {string | undefined} filePath\n *   File path.\n * @property {boolean} ignoreInvalidStyle\n *   Ignore invalid CSS in `style` props.\n * @property {boolean} passKeys\n *   Generate keys to optimize frameworks that support them.\n * @property {boolean} passNode\n *   Pass `node` to components.\n * @property {Schema} schema\n *   Current schema.\n * @property {StylePropertyNameCase} stylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n * @property {boolean} tableCellAlignToStyle\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\n *\n * @typedef {Record<string, string>} Style\n *   Style map.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef {Style | boolean | number | string} Value\n *   Primitive property value and `Style` map.\n */ /**\n * @typedef {RuntimeDevelopment & RegularFields} Development\n *   Configuration (development).\n * @typedef {Development | Production | Unknown} Options\n *   Configuration.\n * @typedef {RegularFields & RuntimeProduction} Production\n *   Configuration (production).\n * @typedef {RegularFields & RuntimeUnknown} Unknown\n *   Configuration (production or development).\n */ \n\n\n\n\n\n\nconst own = {}.hasOwnProperty;\n/** @type {Map<string, number>} */ const emptyMap = new Map();\nconst cap = /[A-Z]/g;\nconst dashSomething = /-([a-z])/g;\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set([\n    \"table\",\n    \"tbody\",\n    \"thead\",\n    \"tfoot\",\n    \"tr\"\n]);\nconst tableCellElement = new Set([\n    \"td\",\n    \"th\"\n]);\n/**\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\n * with an automatic JSX runtime.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options} options\n *   Configuration (required).\n * @returns {JSX.Element}\n *   JSX element.\n */ function toJsxRuntime(tree, options) {\n    if (!options || options.Fragment === undefined) {\n        throw new TypeError(\"Expected `Fragment` in options\");\n    }\n    const filePath = options.filePath || undefined;\n    /** @type {Create} */ let create;\n    if (options.development) {\n        if (typeof options.jsxDEV !== \"function\") {\n            throw new TypeError(\"Expected `jsxDEV` in options when `development: true`\");\n        }\n        create = developmentCreate(filePath, options.jsxDEV);\n    } else {\n        if (typeof options.jsx !== \"function\") {\n            throw new TypeError(\"Expected `jsx` in production options\");\n        }\n        if (typeof options.jsxs !== \"function\") {\n            throw new TypeError(\"Expected `jsxs` in production options\");\n        }\n        create = productionCreate(filePath, options.jsx, options.jsxs);\n    }\n    /** @type {State} */ const state = {\n        Fragment: options.Fragment,\n        ancestors: [],\n        components: options.components || {},\n        create,\n        elementAttributeNameCase: options.elementAttributeNameCase || \"react\",\n        filePath,\n        ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n        passKeys: options.passKeys !== false,\n        passNode: options.passNode || false,\n        schema: options.space === \"svg\" ? property_information__WEBPACK_IMPORTED_MODULE_1__.svg : property_information__WEBPACK_IMPORTED_MODULE_1__.html,\n        stylePropertyNameCase: options.stylePropertyNameCase || \"dom\",\n        tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n    };\n    const result = one(state, tree, undefined);\n    // JSX element.\n    if (result && typeof result !== \"string\") {\n        return result;\n    }\n    // Text node or something that turned into nothing.\n    return state.create(tree, state.Fragment, {\n        children: result || undefined\n    }, undefined);\n}\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Current node.\n * @param {string | undefined} key\n *   Key.\n * @returns {Child | undefined}\n *   Child, optional.\n */ function one(state, node, key) {\n    if (node.type === \"element\" || node.type === \"root\") {\n        const parentSchema = state.schema;\n        let schema = parentSchema;\n        if (node.type === \"element\" && node.tagName.toLowerCase() === \"svg\" && parentSchema.space === \"html\") {\n            schema = property_information__WEBPACK_IMPORTED_MODULE_1__.svg;\n            state.schema = schema;\n        }\n        state.ancestors.push(node);\n        let children = createChildren(state, node);\n        const props = createProperties(state, state.ancestors);\n        let type = state.Fragment;\n        state.ancestors.pop();\n        if (node.type === \"element\") {\n            if (children && tableElements.has(node.tagName)) {\n                children = children.filter(function(child) {\n                    return typeof child === \"string\" ? !(0,hast_util_whitespace__WEBPACK_IMPORTED_MODULE_2__.whitespace)(child) : true;\n                });\n            }\n            if (own.call(state.components, node.tagName)) {\n                const key = /** @type {keyof JSX.IntrinsicElements} */ node.tagName;\n                type = state.components[key];\n                // If this is swapped out for a component:\n                if (typeof type !== \"string\" && type !== state.Fragment && state.passNode) {\n                    props.node = node;\n                }\n            } else {\n                type = node.tagName;\n            }\n        }\n        if (children.length > 0) {\n            const value = children.length > 1 ? children : children[0];\n            if (value) {\n                props.children = value;\n            }\n        }\n        // Restore parent schema.\n        state.schema = parentSchema;\n        return state.create(node, type, props, key);\n    }\n    if (node.type === \"text\") {\n        return node.value;\n    }\n}\n/**\n * @param {string | undefined} _\n *   Path to file.\n * @param {Jsx} jsx\n *   Dynamic.\n * @param {Jsx} jsxs\n *   Static.\n * @returns {Create}\n *   Create a production element.\n */ function productionCreate(_, jsx, jsxs) {\n    return create;\n    /** @type {Create} */ function create(_, type, props, key) {\n        // Only an array when there are 2 or more children.\n        const isStaticChildren = Array.isArray(props.children);\n        const fn = isStaticChildren ? jsxs : jsx;\n        return key ? fn(type, props, key) : fn(type, props);\n    }\n}\n/**\n * @param {string | undefined} filePath\n *   Path to file.\n * @param {JsxDev} jsxDEV\n *   Development.\n * @returns {Create}\n *   Create a development element.\n */ function developmentCreate(filePath, jsxDEV) {\n    return create;\n    /** @type {Create} */ function create(node, type, props, key) {\n        // Only an array when there are 2 or more children.\n        const isStaticChildren = Array.isArray(props.children);\n        const point = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_3__.pointStart)(node);\n        return jsxDEV(type, props, key, isStaticChildren, {\n            columnNumber: point ? point.column - 1 : undefined,\n            fileName: filePath,\n            lineNumber: point ? point.line : undefined\n        }, undefined);\n    }\n}\n/**\n * Create children.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Parents} node\n *   Current element.\n * @returns {Array<Child>}\n *   Children.\n */ function createChildren(state, node) {\n    /** @type {Array<Child>} */ const children = [];\n    let index = -1;\n    /** @type {Map<string, number>} */ // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n    /* c8 ignore next */ const countsByTagName = state.passKeys ? new Map() : emptyMap;\n    while(++index < node.children.length){\n        const child = node.children[index];\n        /** @type {string | undefined} */ let key;\n        if (state.passKeys && child.type === \"element\") {\n            const count = countsByTagName.get(child.tagName) || 0;\n            key = child.tagName + \"-\" + count;\n            countsByTagName.set(child.tagName, count + 1);\n        }\n        const result = one(state, child, key);\n        if (result !== undefined) children.push(result);\n    }\n    return children;\n}\n/**\n * Handle properties.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Array<Parents>} ancestors\n *   Stack of parents.\n * @returns {Props}\n *   Props for runtime.\n */ function createProperties(state, ancestors) {\n    const node = ancestors[ancestors.length - 1];\n    /** @type {Props} */ const props = {};\n    /** @type {string} */ let prop;\n    if (\"properties\" in node && node.properties) {\n        /** @type {string | undefined} */ let alignValue;\n        for(prop in node.properties){\n            if (prop !== \"children\" && own.call(node.properties, prop)) {\n                const result = createProperty(state, ancestors, prop, node.properties[prop]);\n                if (result) {\n                    const [key, value] = result;\n                    if (state.tableCellAlignToStyle && key === \"align\" && typeof value === \"string\" && tableCellElement.has(node.tagName)) {\n                        alignValue = value;\n                    } else {\n                        props[key] = value;\n                    }\n                }\n            }\n        }\n        if (alignValue) {\n            // Assume style is an object.\n            const style = /** @type {Style} */ props.style || (props.style = {});\n            style[state.stylePropertyNameCase === \"css\" ? \"text-align\" : \"textAlign\"] = alignValue;\n        }\n    }\n    return props;\n}\n/**\n * Handle a property.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Array<Parents>} ancestors\n *   Stack of parents.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Field | undefined}\n *   Field for runtime, optional.\n */ function createProperty(state, ancestors, prop, value) {\n    const info = (0,property_information__WEBPACK_IMPORTED_MODULE_4__.find)(state.schema, prop);\n    // Ignore nullish and `NaN` values.\n    if (value === null || value === undefined || typeof value === \"number\" && Number.isNaN(value)) {\n        return;\n    }\n    if (Array.isArray(value)) {\n        // Accept `array`.\n        // Most props are space-separated.\n        value = info.commaSeparated ? (0,comma_separated_tokens__WEBPACK_IMPORTED_MODULE_5__.stringify)(value) : (0,space_separated_tokens__WEBPACK_IMPORTED_MODULE_6__.stringify)(value);\n    }\n    // React only accepts `style` as object.\n    if (info.property === \"style\") {\n        let styleObject = typeof value === \"object\" ? value : parseStyle(state, ancestors, String(value));\n        if (state.stylePropertyNameCase === \"css\") {\n            styleObject = transformStylesToCssCasing(styleObject);\n        }\n        return [\n            \"style\",\n            styleObject\n        ];\n    }\n    return [\n        state.elementAttributeNameCase === \"react\" && info.space ? property_information__WEBPACK_IMPORTED_MODULE_7__.hastToReact[info.property] || info.property : info.attribute,\n        value\n    ];\n}\n/**\n * Parse a CSS declaration to an object.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Array<Nodes>} ancestors\n *   Stack of nodes.\n * @param {string} value\n *   CSS declarations.\n * @returns {Style}\n *   Properties.\n * @throws\n *   Throws `VFileMessage` when CSS cannot be parsed.\n */ function parseStyle(state, ancestors, value) {\n    /** @type {Style} */ const result = {};\n    try {\n        (0,style_to_object__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(value, replacer);\n    } catch (error) {\n        if (!state.ignoreInvalidStyle) {\n            const cause = /** @type {Error} */ error;\n            const message = new vfile_message__WEBPACK_IMPORTED_MODULE_8__.VFileMessage(\"Cannot parse `style` attribute\", {\n                ancestors,\n                cause,\n                source: \"hast-util-to-jsx-runtime\",\n                ruleId: \"style\"\n            });\n            message.file = state.filePath || undefined;\n            message.url = \"https://github.com/syntax-tree/hast-util-to-jsx-runtime#cannot-parse-style-attribute\";\n            throw message;\n        }\n    }\n    return result;\n    /**\n   * Add a CSS property (normal, so with dashes) to `result` as a DOM CSS\n   * property.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value\n   * @returns {undefined}\n   *   Nothing.\n   */ function replacer(name, value) {\n        let key = name;\n        if (key.slice(0, 2) !== \"--\") {\n            if (key.slice(0, 4) === \"-ms-\") key = \"ms-\" + key.slice(4);\n            key = key.replace(dashSomething, toCamel);\n        }\n        result[key] = value;\n    }\n}\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */ function transformStylesToCssCasing(domCasing) {\n    /** @type {Style} */ const cssCasing = {};\n    /** @type {string} */ let from;\n    for(from in domCasing){\n        if (own.call(domCasing, from)) {\n            cssCasing[transformStyleToCssCasing(from)] = domCasing[from];\n        }\n    }\n    return cssCasing;\n}\n/**\n * Transform a DOM casing style field to a CSS casing style field.\n *\n * @param {string} from\n * @returns {string}\n */ function transformStyleToCssCasing(from) {\n    let to = from.replace(cap, toDash);\n    // Handle `ms-xxx` -> `-ms-xxx`.\n    if (to.slice(0, 3) === \"ms-\") to = \"-\" + to;\n    return to;\n}\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */ function toCamel(_, $1) {\n    return $1.toUpperCase();\n}\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */ function toDash($0) {\n    return \"-\" + $0.toLowerCase();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0NBUUMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkxDLEdBRUQ7Ozs7Ozs7OztDQVNDLEdBRXlEO0FBQ1g7QUFDa0I7QUFDUDtBQUNmO0FBQ0c7QUFDSjtBQUUxQyxNQUFNVyxNQUFNLENBQUMsRUFBRUMsY0FBYztBQUU3QixnQ0FBZ0MsR0FDaEMsTUFBTUMsV0FBVyxJQUFJQztBQUVyQixNQUFNQyxNQUFNO0FBQ1osTUFBTUMsZ0JBQWdCO0FBRXRCLGtFQUFrRTtBQUNsRSw2RUFBNkU7QUFDN0UsMkVBQTJFO0FBQzNFLFFBQVE7QUFFUixzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELDZEQUE2RDtBQUM3RCwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELDJEQUEyRDtBQUMzRCxNQUFNQyxnQkFBZ0IsSUFBSUMsSUFBSTtJQUFDO0lBQVM7SUFBUztJQUFTO0lBQVM7Q0FBSztBQUV4RSxNQUFNQyxtQkFBbUIsSUFBSUQsSUFBSTtJQUFDO0lBQU07Q0FBSztBQUU3Qzs7Ozs7Ozs7OztDQVVDLEdBRU0sU0FBU0UsYUFBYUMsSUFBSSxFQUFFQyxPQUFPO0lBQ3hDLElBQUksQ0FBQ0EsV0FBV0EsUUFBUUMsUUFBUSxLQUFLQyxXQUFXO1FBQzlDLE1BQU0sSUFBSUMsVUFBVTtJQUN0QjtJQUVBLE1BQU1DLFdBQVdKLFFBQVFJLFFBQVEsSUFBSUY7SUFDckMsbUJBQW1CLEdBQ25CLElBQUlHO0lB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LEdBQUcvRCxXQUFXO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGdwdC1saXRlLy4vbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9saWIvaW5kZXguanM/OThjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5FbGVtZW50fSBFbGVtZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuTm9kZXN9IE5vZGVzXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuUGFyZW50c30gUGFyZW50c1xuICpcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3Byb3BlcnR5LWluZm9ybWF0aW9uJykuU2NoZW1hfSBTY2hlbWFcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbXBvbmVudHMuanMnKS5Db21wb25lbnRzfSBDb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7SlNYLkVsZW1lbnQgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBDaGlsZFxuICogICBDaGlsZC5cbiAqXG4gKiBAY2FsbGJhY2sgQ3JlYXRlXG4gKiAgIENyZWF0ZSBzb21ldGhpbmcgaW4gZGV2ZWxvcG1lbnQgb3IgcHJvZHVjdGlvbi5cbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqICAgaGFzdCBub2RlLlxuICogQHBhcmFtIHt1bmtub3dufSB0eXBlXG4gKiAgIEZyYWdtZW50IHN5bWJvbCBvciB0YWcgbmFtZS5cbiAqIEBwYXJhbSB7UHJvcHN9IHByb3BzXG4gKiAgIFByb3BlcnRpZXMgYW5kIGNoaWxkcmVuLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBLZXkuXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9XG4gKiAgIFJlc3VsdC5cbiAqXG4gKiBAdHlwZWRlZiB7J2h0bWwnIHwgJ3JlYWN0J30gRWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlXG4gKiAgIENhc2luZyB0byB1c2UgZm9yIGF0dHJpYnV0ZSBuYW1lcy5cbiAqXG4gKiAgIEhUTUwgY2FzaW5nIGlzIGZvciBleGFtcGxlIGBjbGFzc2AsIGBzdHJva2UtbGluZWNhcGAsIGB4bWw6bGFuZ2AuXG4gKiAgIFJlYWN0IGNhc2luZyBpcyBmb3IgZXhhbXBsZSBgY2xhc3NOYW1lYCwgYHN0cm9rZUxpbmVjYXBgLCBgeG1sTGFuZ2AuXG4gKlxuICogQHR5cGVkZWYge1tzdHJpbmcsIFZhbHVlXX0gRmllbGRcbiAqICAgUHJvcGVydHkgZmllbGQuXG4gKlxuICogQHR5cGVkZWYge3Vua25vd259IEZyYWdtZW50XG4gKiAgIFJlcHJlc2VudCB0aGUgY2hpbGRyZW4sIHR5cGljYWxseSBhIHN5bWJvbC5cbiAqXG4gKiBAY2FsbGJhY2sgSnN4XG4gKiAgIENyZWF0ZSBhIHByb2R1Y3Rpb24gZWxlbWVudC5cbiAqIEBwYXJhbSB7dW5rbm93bn0gdHlwZVxuICogICBFbGVtZW50IHR5cGU6IGBGcmFnbWVudGAgc3ltYm9sLCB0YWcgbmFtZSAoYHN0cmluZ2ApLCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge1Byb3BzfSBwcm9wc1xuICogICBFbGVtZW50IHByb3BzLCBgY2hpbGRyZW5gLCBhbmQgbWF5YmUgYG5vZGVgLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtrZXldXG4gKiAgIER5bmFtaWNseSBnZW5lcmF0ZWQga2V5IHRvIHVzZS5cbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH1cbiAqICAgQW4gZWxlbWVudCBmcm9tIHlvdXIgZnJhbWV3b3JrLlxuICpcbiAqIEBjYWxsYmFjayBKc3hEZXZcbiAqICAgQ3JlYXRlIGEgZGV2ZWxvcG1lbnQgZWxlbWVudC5cbiAqIEBwYXJhbSB7dW5rbm93bn0gdHlwZVxuICogICBFbGVtZW50IHR5cGU6IGBGcmFnbWVudGAgc3ltYm9sLCB0YWcgbmFtZSAoYHN0cmluZ2ApLCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge1Byb3BzfSBwcm9wc1xuICogICBFbGVtZW50IHByb3BzLCBgY2hpbGRyZW5gLCBhbmQgbWF5YmUgYG5vZGVgLlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGtleVxuICogICBEeW5hbWljbHkgZ2VuZXJhdGVkIGtleSB0byB1c2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3RhdGljQ2hpbGRyZW5cbiAqICAgV2hldGhlciB0d28gb3IgbW9yZSBjaGlsZHJlbiBhcmUgcGFzc2VkIChpbiBhbiBhcnJheSksIHdoaWNoIGlzIHdoZXRoZXJcbiAqICAgYGpzeHNgIG9yIGBqc3hgIHdvdWxkIGJlIHVzZWQuXG4gKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG4gKiAgIEluZm8gYWJvdXQgc291cmNlLlxuICogQHBhcmFtIHt1bmRlZmluZWR9IHNlbGZcbiAqICAgTm90aGluZyAodGhpcyBpcyB1c2VkIGJ5IGZyYW1ld29ya3MgdGhhdCBoYXZlIGNvbXBvbmVudHMsIHdlIGRvbuKAmXQpLlxuICogQHJldHVybnMge0pTWC5FbGVtZW50fVxuICogICBBbiBlbGVtZW50IGZyb20geW91ciBmcmFtZXdvcmsuXG4gKlxuICogQHR5cGVkZWYge3tjaGlsZHJlbj86IEFycmF5PENoaWxkPiB8IENoaWxkLCBub2RlPzogRWxlbWVudCB8IHVuZGVmaW5lZCwgW3Byb3A6IHN0cmluZ106IEFycmF5PENoaWxkPiB8IENoaWxkIHwgRWxlbWVudCB8IFZhbHVlIHwgdW5kZWZpbmVkfX0gUHJvcHNcbiAqICAgUHJvcGVydGllcyBhbmQgY2hpbGRyZW4uXG4gKlxuICogQHR5cGVkZWYgUmVndWxhckZpZWxkc1xuICogICBDb25maWd1cmF0aW9uLlxuICogQHByb3BlcnR5IHtQYXJ0aWFsPENvbXBvbmVudHM+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2NvbXBvbmVudHNdXG4gKiAgIENvbXBvbmVudHMgdG8gdXNlIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0VsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSB8IG51bGwgfCB1bmRlZmluZWR9IFtlbGVtZW50QXR0cmlidXRlTmFtZUNhc2U9J3JlYWN0J11cbiAqICAgU3BlY2lmeSBjYXNpbmcgdG8gdXNlIGZvciBhdHRyaWJ1dGUgbmFtZXMgKGRlZmF1bHQ6IGAncmVhY3QnYCkuXG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtmaWxlUGF0aF1cbiAqICAgRmlsZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAob3B0aW9uYWwpLlxuICpcbiAqICAgUGFzc2VkIGluIHNvdXJjZSBpbmZvIHRvIGBqc3hERVZgIHdoZW4gdXNpbmcgdGhlIGF1dG9tYXRpYyBydW50aW1lIHdpdGhcbiAqICAgYGRldmVsb3BtZW50OiB0cnVlYC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtpZ25vcmVJbnZhbGlkU3R5bGU9ZmFsc2VdXG4gKiAgIElnbm9yZSBpbnZhbGlkIENTUyBpbiBgc3R5bGVgIHByb3BzIChkZWZhdWx0OiBgZmFsc2VgKTtcbiAqICAgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcGFzc0tleXM9dHJ1ZV1cbiAqICAgR2VuZXJhdGUga2V5cyB0byBvcHRpbWl6ZSBmcmFtZXdvcmtzIHRoYXQgc3VwcG9ydCB0aGVtIChkZWZhdWx0OiBgdHJ1ZWApLlxuICpcbiAqICAgPiDwn5GJICoqTm90ZSoqOiBTb2xpZCBjdXJyZW50bHkgZmFpbHMgaWYga2V5cyBhcmUgcGFzc2VkLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Bhc3NOb2RlPWZhbHNlXVxuICogICBQYXNzIHRoZSBoYXN0IGVsZW1lbnQgbm9kZSB0byBjb21wb25lbnRzIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAqIEBwcm9wZXJ0eSB7U3BhY2UgfCBudWxsIHwgdW5kZWZpbmVkfSBbc3BhY2U9J2h0bWwnXVxuICogICBXaGV0aGVyIGB0cmVlYCBpcyBpbiB0aGUgYCdodG1sJ2Agb3IgYCdzdmcnYCBzcGFjZSAoZGVmYXVsdDogYCdodG1sJ2ApLlxuICpcbiAqICAgV2hlbiBhbiBgPHN2Zz5gIGVsZW1lbnQgaXMgZm91bmQgaW4gdGhlIEhUTUwgc3BhY2UsIHRoaXMgcGFja2FnZSBhbHJlYWR5XG4gKiAgIGF1dG9tYXRpY2FsbHkgc3dpdGNoZXMgdG8gYW5kIGZyb20gdGhlIFNWRyBzcGFjZSB3aGVuIGVudGVyaW5nIGFuZCBleGl0aW5nXG4gKiAgIGl0LlxuICogQHByb3BlcnR5IHtTdHlsZVByb3BlcnR5TmFtZUNhc2UgfCBudWxsIHwgdW5kZWZpbmVkfSBbc3R5bGVQcm9wZXJ0eU5hbWVDYXNlPSdkb20nXVxuICogICBTcGVjaWZ5IGNhc2luZyB0byB1c2UgZm9yIHByb3BlcnR5IG5hbWVzIGluIGBzdHlsZWAgb2JqZWN0cyAoZGVmYXVsdDpcbiAqICAgYCdkb20nYCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbdGFibGVDZWxsQWxpZ25Ub1N0eWxlPXRydWVdXG4gKiAgIFR1cm4gb2Jzb2xldGUgYGFsaWduYCBwcm9wcyBvbiBgdGRgIGFuZCBgdGhgIGludG8gQ1NTIGBzdHlsZWAgcHJvcHNcbiAqICAgKGRlZmF1bHQ6IGB0cnVlYCkuXG4gKlxuICogQHR5cGVkZWYgUnVudGltZURldmVsb3BtZW50XG4gKiAgIFJ1bnRpbWUgZmllbGRzIHdoZW4gZGV2ZWxvcG1lbnQgaXMgb24uXG4gKiBAcHJvcGVydHkge0ZyYWdtZW50fSBGcmFnbWVudFxuICogICBGcmFnbWVudC5cbiAqIEBwcm9wZXJ0eSB7dHJ1ZX0gZGV2ZWxvcG1lbnRcbiAqICAgV2hldGhlciB0byB1c2UgYGpzeERFVmAgKHdoZW4gb24pIG9yIGBqc3hgIGFuZCBganN4c2AgKHdoZW4gb2ZmKS5cbiAqIEBwcm9wZXJ0eSB7SnN4IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2pzeF1cbiAqICAgRHluYW1pYyBKU1ggKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7SnN4RGV2fSBqc3hERVZcbiAqICAgRGV2ZWxvcG1lbnQgSlNYLlxuICogQHByb3BlcnR5IHtKc3ggfCBudWxsIHwgdW5kZWZpbmVkfSBbanN4c11cbiAqICAgU3RhdGljIEpTWCAob3B0aW9uYWwpLlxuICpcbiAqIEB0eXBlZGVmIFJ1bnRpbWVQcm9kdWN0aW9uXG4gKiAgIFJ1bnRpbWUgZmllbGRzIHdoZW4gZGV2ZWxvcG1lbnQgaXMgb2ZmLlxuICogQHByb3BlcnR5IHtGcmFnbWVudH0gRnJhZ21lbnRcbiAqICAgRnJhZ21lbnQuXG4gKiBAcHJvcGVydHkge2ZhbHNlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2RldmVsb3BtZW50XVxuICogICBXaGV0aGVyIHRvIHVzZSBganN4REVWYCAod2hlbiBvbikgb3IgYGpzeGAgYW5kIGBqc3hzYCAod2hlbiBvZmYpIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0pzeH0ganN4XG4gKiAgIER5bmFtaWMgSlNYLlxuICogQHByb3BlcnR5IHtKc3hEZXYgfCBudWxsIHwgdW5kZWZpbmVkfSBbanN4REVWXVxuICogICBEZXZlbG9wbWVudCBKU1ggKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7SnN4fSBqc3hzXG4gKiAgIFN0YXRpYyBKU1guXG4gKlxuICogQHR5cGVkZWYgUnVudGltZVVua25vd25cbiAqICAgUnVudGltZSBmaWVsZHMgd2hlbiBkZXZlbG9wbWVudCBtaWdodCBiZSBvbiBvciBvZmYuXG4gKiBAcHJvcGVydHkge0ZyYWdtZW50fSBGcmFnbWVudFxuICogICBGcmFnbWVudC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZGV2ZWxvcG1lbnRcbiAqICAgV2hldGhlciB0byB1c2UgYGpzeERFVmAgKHdoZW4gb24pIG9yIGBqc3hgIGFuZCBganN4c2AgKHdoZW4gb2ZmKS5cbiAqIEBwcm9wZXJ0eSB7SnN4IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2pzeF1cbiAqICAgRHluYW1pYyBKU1ggKG9wdGlvbmFsKS5cbiAqIEBwcm9wZXJ0eSB7SnN4RGV2IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2pzeERFVl1cbiAqICAgRGV2ZWxvcG1lbnQgSlNYIChvcHRpb25hbCkuXG4gKiBAcHJvcGVydHkge0pzeCB8IG51bGwgfCB1bmRlZmluZWR9IFtqc3hzXVxuICogICBTdGF0aWMgSlNYIChvcHRpb25hbCkuXG4gKlxuICogQHR5cGVkZWYgU291cmNlXG4gKiAgIEluZm8gYWJvdXQgc291cmNlLlxuICogQHByb3BlcnR5IHtudW1iZXIgfCB1bmRlZmluZWR9IGNvbHVtbk51bWJlclxuICogICBDb2x1bW4gd2hlcmUgdGhpbmcgc3RhcnRzICgwLWluZGV4ZWQpLlxuICogQHByb3BlcnR5IHtzdHJpbmcgfCB1bmRlZmluZWR9IGZpbGVOYW1lXG4gKiAgIE5hbWUgb2Ygc291cmNlIGZpbGUuXG4gKiBAcHJvcGVydHkge251bWJlciB8IHVuZGVmaW5lZH0gbGluZU51bWJlclxuICogICBMaW5lIHdoZXJlIHRoaW5nIHN0YXJ0cyAoMS1pbmRleGVkKS5cbiAqXG4gKiBAdHlwZWRlZiB7J2h0bWwnIHwgJ3N2Zyd9IFNwYWNlXG4gKiAgIE5hbWVzcGFjZS5cbiAqXG4gKiAgID4g8J+RiSAqKk5vdGUqKjogaGFzdCBpcyBub3QgWE1MLlxuICogICA+IEl0IHN1cHBvcnRzIFNWRyBhcyBlbWJlZGRlZCBpbiBIVE1MLlxuICogICA+IEl0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGZlYXR1cmVzIGF2YWlsYWJsZSBpbiBYTUwuXG4gKiAgID4gUGFzc2luZyBTVkcgbWlnaHQgYnJlYWsgYnV0IGZyYWdtZW50cyBvZiBtb2Rlcm4gU1ZHIHNob3VsZCBiZSBmaW5lLlxuICogICA+IFVzZSBgeGFzdGAgaWYgeW91IG5lZWQgdG8gc3VwcG9ydCBTVkcgYXMgWE1MLlxuICpcbiAqIEB0eXBlZGVmIFN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwcm9wZXJ0eSB7dW5rbm93bn0gRnJhZ21lbnRcbiAqICAgRnJhZ21lbnQgc3ltYm9sLlxuICogQHByb3BlcnR5IHtBcnJheTxQYXJlbnRzPn0gYW5jZXN0b3JzXG4gKiAgIFN0YWNrIG9mIHBhcmVudHMuXG4gKiBAcHJvcGVydHkge1BhcnRpYWw8Q29tcG9uZW50cz59IGNvbXBvbmVudHNcbiAqICAgQ29tcG9uZW50cyB0byBzd2FwLlxuICogQHByb3BlcnR5IHtDcmVhdGV9IGNyZWF0ZVxuICogICBDcmVhdGUgc29tZXRoaW5nIGluIGRldmVsb3BtZW50IG9yIHByb2R1Y3Rpb24uXG4gKiBAcHJvcGVydHkge0VsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZX0gZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlXG4gKiAgIENhc2luZyB0byB1c2UgZm9yIGF0dHJpYnV0ZSBuYW1lcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBmaWxlUGF0aFxuICogICBGaWxlIHBhdGguXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlnbm9yZUludmFsaWRTdHlsZVxuICogICBJZ25vcmUgaW52YWxpZCBDU1MgaW4gYHN0eWxlYCBwcm9wcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGFzc0tleXNcbiAqICAgR2VuZXJhdGUga2V5cyB0byBvcHRpbWl6ZSBmcmFtZXdvcmtzIHRoYXQgc3VwcG9ydCB0aGVtLlxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXNzTm9kZVxuICogICBQYXNzIGBub2RlYCB0byBjb21wb25lbnRzLlxuICogQHByb3BlcnR5IHtTY2hlbWF9IHNjaGVtYVxuICogICBDdXJyZW50IHNjaGVtYS5cbiAqIEBwcm9wZXJ0eSB7U3R5bGVQcm9wZXJ0eU5hbWVDYXNlfSBzdHlsZVByb3BlcnR5TmFtZUNhc2VcbiAqICAgQ2FzaW5nIHRvIHVzZSBmb3IgcHJvcGVydHkgbmFtZXMgaW4gYHN0eWxlYCBvYmplY3RzLlxuICogQHByb3BlcnR5IHtib29sZWFufSB0YWJsZUNlbGxBbGlnblRvU3R5bGVcbiAqICAgVHVybiBvYnNvbGV0ZSBgYWxpZ25gIHByb3BzIG9uIGB0ZGAgYW5kIGB0aGAgaW50byBDU1MgYHN0eWxlYCBwcm9wcy5cbiAqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gU3R5bGVcbiAqICAgU3R5bGUgbWFwLlxuICpcbiAqIEB0eXBlZGVmIHsnY3NzJyB8ICdkb20nfSBTdHlsZVByb3BlcnR5TmFtZUNhc2VcbiAqICAgQ2FzaW5nIHRvIHVzZSBmb3IgcHJvcGVydHkgbmFtZXMgaW4gYHN0eWxlYCBvYmplY3RzLlxuICpcbiAqICAgQ1NTIGNhc2luZyBpcyBmb3IgZXhhbXBsZSBgYmFja2dyb3VuZC1jb2xvcmAgYW5kIGAtd2Via2l0LWxpbmUtY2xhbXBgLlxuICogICBET00gY2FzaW5nIGlzIGZvciBleGFtcGxlIGBiYWNrZ3JvdW5kQ29sb3JgIGFuZCBgV2Via2l0TGluZUNsYW1wYC5cbiAqXG4gKiBAdHlwZWRlZiB7U3R5bGUgfCBib29sZWFuIHwgbnVtYmVyIHwgc3RyaW5nfSBWYWx1ZVxuICogICBQcmltaXRpdmUgcHJvcGVydHkgdmFsdWUgYW5kIGBTdHlsZWAgbWFwLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge1J1bnRpbWVEZXZlbG9wbWVudCAmIFJlZ3VsYXJGaWVsZHN9IERldmVsb3BtZW50XG4gKiAgIENvbmZpZ3VyYXRpb24gKGRldmVsb3BtZW50KS5cbiAqIEB0eXBlZGVmIHtEZXZlbG9wbWVudCB8IFByb2R1Y3Rpb24gfCBVbmtub3dufSBPcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAdHlwZWRlZiB7UmVndWxhckZpZWxkcyAmIFJ1bnRpbWVQcm9kdWN0aW9ufSBQcm9kdWN0aW9uXG4gKiAgIENvbmZpZ3VyYXRpb24gKHByb2R1Y3Rpb24pLlxuICogQHR5cGVkZWYge1JlZ3VsYXJGaWVsZHMgJiBSdW50aW1lVW5rbm93bn0gVW5rbm93blxuICogICBDb25maWd1cmF0aW9uIChwcm9kdWN0aW9uIG9yIGRldmVsb3BtZW50KS5cbiAqL1xuXG5pbXBvcnQge3N0cmluZ2lmeSBhcyBjb21tYXN9IGZyb20gJ2NvbW1hLXNlcGFyYXRlZC10b2tlbnMnXG5pbXBvcnQge3doaXRlc3BhY2V9IGZyb20gJ2hhc3QtdXRpbC13aGl0ZXNwYWNlJ1xuaW1wb3J0IHtmaW5kLCBoYXN0VG9SZWFjdCwgaHRtbCwgc3ZnfSBmcm9tICdwcm9wZXJ0eS1pbmZvcm1hdGlvbidcbmltcG9ydCB7c3RyaW5naWZ5IGFzIHNwYWNlc30gZnJvbSAnc3BhY2Utc2VwYXJhdGVkLXRva2VucydcbmltcG9ydCBzdHlsZVRvT2JqZWN0IGZyb20gJ3N0eWxlLXRvLW9iamVjdCdcbmltcG9ydCB7cG9pbnRTdGFydH0gZnJvbSAndW5pc3QtdXRpbC1wb3NpdGlvbidcbmltcG9ydCB7VkZpbGVNZXNzYWdlfSBmcm9tICd2ZmlsZS1tZXNzYWdlJ1xuXG5jb25zdCBvd24gPSB7fS5oYXNPd25Qcm9wZXJ0eVxuXG4vKiogQHR5cGUge01hcDxzdHJpbmcsIG51bWJlcj59ICovXG5jb25zdCBlbXB0eU1hcCA9IG5ldyBNYXAoKVxuXG5jb25zdCBjYXAgPSAvW0EtWl0vZ1xuY29uc3QgZGFzaFNvbWV0aGluZyA9IC8tKFthLXpdKS9nXG5cbi8vIGByZWFjdC1kb21gIHRyaWdnZXJzIGEgd2FybmluZyBmb3IgKmFueSogd2hpdGUgc3BhY2UgaW4gdGFibGVzLlxuLy8gVG8gZm9sbG93IEdGTSwgYG1kYXN0LXV0aWwtdG8taGFzdGAgaW5qZWN0cyBsaW5lIGVuZGluZ3MgYmV0d2VlbiBlbGVtZW50cy5cbi8vIE90aGVyIHRvb2xzIG1pZ2h0IGRvIHNvIHRvbywgYnV0IHRoZXkgZG9u4oCZdCBkbyBoZXJlLCBzbyB3ZSByZW1vdmUgYWxsIG9mXG4vLyB0aGF0LlxuXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MDgxPi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzc1MTU+LlxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL3JlbWFya2pzL3JlbWFyay1yZWFjdC9pc3N1ZXMvNjQ+LlxuLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL3JlaHlwZWpzL3JlaHlwZS1yZWFjdC9wdWxsLzI5Pi5cbi8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9yZWh5cGVqcy9yZWh5cGUtcmVhY3QvcHVsbC8zMj4uXG4vLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0L3B1bGwvNDU+LlxuY29uc3QgdGFibGVFbGVtZW50cyA9IG5ldyBTZXQoWyd0YWJsZScsICd0Ym9keScsICd0aGVhZCcsICd0Zm9vdCcsICd0ciddKVxuXG5jb25zdCB0YWJsZUNlbGxFbGVtZW50ID0gbmV3IFNldChbJ3RkJywgJ3RoJ10pXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgaGFzdCB0cmVlIHRvIHByZWFjdCwgcmVhY3QsIHNvbGlkLCBzdmVsdGUsIHZ1ZSwgZXRjLixcbiAqIHdpdGggYW4gYXV0b21hdGljIEpTWCBydW50aW1lLlxuICpcbiAqIEBwYXJhbSB7Tm9kZXN9IHRyZWVcbiAqICAgVHJlZSB0byB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiAocmVxdWlyZWQpLlxuICogQHJldHVybnMge0pTWC5FbGVtZW50fVxuICogICBKU1ggZWxlbWVudC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdG9Kc3hSdW50aW1lKHRyZWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBGcmFnbWVudGAgaW4gb3B0aW9ucycpXG4gIH1cblxuICBjb25zdCBmaWxlUGF0aCA9IG9wdGlvbnMuZmlsZVBhdGggfHwgdW5kZWZpbmVkXG4gIC8qKiBAdHlwZSB7Q3JlYXRlfSAqL1xuICBsZXQgY3JlYXRlXG5cbiAgaWYgKG9wdGlvbnMuZGV2ZWxvcG1lbnQpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuanN4REVWICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnRXhwZWN0ZWQgYGpzeERFVmAgaW4gb3B0aW9ucyB3aGVuIGBkZXZlbG9wbWVudDogdHJ1ZWAnXG4gICAgICApXG4gICAgfVxuXG4gICAgY3JlYXRlID0gZGV2ZWxvcG1lbnRDcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4REVWKVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5qc3ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBqc3hgIGluIHByb2R1Y3Rpb24gb3B0aW9ucycpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmpzeHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBqc3hzYCBpbiBwcm9kdWN0aW9uIG9wdGlvbnMnKVxuICAgIH1cblxuICAgIGNyZWF0ZSA9IHByb2R1Y3Rpb25DcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4LCBvcHRpb25zLmpzeHMpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBGcmFnbWVudDogb3B0aW9ucy5GcmFnbWVudCxcbiAgICBhbmNlc3RvcnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IG9wdGlvbnMuY29tcG9uZW50cyB8fCB7fSxcbiAgICBjcmVhdGUsXG4gICAgZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlOiBvcHRpb25zLmVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSB8fCAncmVhY3QnLFxuICAgIGZpbGVQYXRoLFxuICAgIGlnbm9yZUludmFsaWRTdHlsZTogb3B0aW9ucy5pZ25vcmVJbnZhbGlkU3R5bGUgfHwgZmFsc2UsXG4gICAgcGFzc0tleXM6IG9wdGlvbnMucGFzc0tleXMgIT09IGZhbHNlLFxuICAgIHBhc3NOb2RlOiBvcHRpb25zLnBhc3NOb2RlIHx8IGZhbHNlLFxuICAgIHNjaGVtYTogb3B0aW9ucy5zcGFjZSA9PT0gJ3N2ZycgPyBzdmcgOiBodG1sLFxuICAgIHN0eWxlUHJvcGVydHlOYW1lQ2FzZTogb3B0aW9ucy5zdHlsZVByb3BlcnR5TmFtZUNhc2UgfHwgJ2RvbScsXG4gICAgdGFibGVDZWxsQWxpZ25Ub1N0eWxlOiBvcHRpb25zLnRhYmxlQ2VsbEFsaWduVG9TdHlsZSAhPT0gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IG9uZShzdGF0ZSwgdHJlZSwgdW5kZWZpbmVkKVxuXG4gIC8vIEpTWCBlbGVtZW50LlxuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gVGV4dCBub2RlIG9yIHNvbWV0aGluZyB0aGF0IHR1cm5lZCBpbnRvIG5vdGhpbmcuXG4gIHJldHVybiBzdGF0ZS5jcmVhdGUoXG4gICAgdHJlZSxcbiAgICBzdGF0ZS5GcmFnbWVudCxcbiAgICB7Y2hpbGRyZW46IHJlc3VsdCB8fCB1bmRlZmluZWR9LFxuICAgIHVuZGVmaW5lZFxuICApXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge05vZGVzfSBub2RlXG4gKiAgIEN1cnJlbnQgbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBrZXlcbiAqICAgS2V5LlxuICogQHJldHVybnMge0NoaWxkIHwgdW5kZWZpbmVkfVxuICogICBDaGlsZCwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIG9uZShzdGF0ZSwgbm9kZSwga2V5KSB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdlbGVtZW50JyB8fCBub2RlLnR5cGUgPT09ICdyb290Jykge1xuICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IHN0YXRlLnNjaGVtYVxuICAgIGxldCBzY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICAgIGlmIChcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2VsZW1lbnQnICYmXG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycgJiZcbiAgICAgIHBhcmVudFNjaGVtYS5zcGFjZSA9PT0gJ2h0bWwnXG4gICAgKSB7XG4gICAgICBzY2hlbWEgPSBzdmdcbiAgICAgIHN0YXRlLnNjaGVtYSA9IHNjaGVtYVxuICAgIH1cblxuICAgIHN0YXRlLmFuY2VzdG9ycy5wdXNoKG5vZGUpXG5cbiAgICBsZXQgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbihzdGF0ZSwgbm9kZSlcbiAgICBjb25zdCBwcm9wcyA9IGNyZWF0ZVByb3BlcnRpZXMoc3RhdGUsIHN0YXRlLmFuY2VzdG9ycylcbiAgICBsZXQgdHlwZSA9IHN0YXRlLkZyYWdtZW50XG5cbiAgICBzdGF0ZS5hbmNlc3RvcnMucG9wKClcblxuICAgIGlmIChub2RlLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgaWYgKGNoaWxkcmVuICYmIHRhYmxlRWxlbWVudHMuaGFzKG5vZGUudGFnTmFtZSkpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgPyAhd2hpdGVzcGFjZShjaGlsZCkgOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGlmIChvd24uY2FsbChzdGF0ZS5jb21wb25lbnRzLCBub2RlLnRhZ05hbWUpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7a2V5b2YgSlNYLkludHJpbnNpY0VsZW1lbnRzfSAqLyAobm9kZS50YWdOYW1lKVxuICAgICAgICB0eXBlID0gc3RhdGUuY29tcG9uZW50c1trZXldXG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyBzd2FwcGVkIG91dCBmb3IgYSBjb21wb25lbnQ6XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICB0eXBlICE9PSBzdGF0ZS5GcmFnbWVudCAmJlxuICAgICAgICAgIHN0YXRlLnBhc3NOb2RlXG4gICAgICAgICkge1xuICAgICAgICAgIHByb3BzLm5vZGUgPSBub2RlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSBub2RlLnRhZ05hbWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjaGlsZHJlbi5sZW5ndGggPiAxID8gY2hpbGRyZW4gOiBjaGlsZHJlblswXVxuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc3RvcmUgcGFyZW50IHNjaGVtYS5cbiAgICBzdGF0ZS5zY2hlbWEgPSBwYXJlbnRTY2hlbWFcblxuICAgIHJldHVybiBzdGF0ZS5jcmVhdGUobm9kZSwgdHlwZSwgcHJvcHMsIGtleSlcbiAgfVxuXG4gIGlmIChub2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBub2RlLnZhbHVlXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gX1xuICogICBQYXRoIHRvIGZpbGUuXG4gKiBAcGFyYW0ge0pzeH0ganN4XG4gKiAgIER5bmFtaWMuXG4gKiBAcGFyYW0ge0pzeH0ganN4c1xuICogICBTdGF0aWMuXG4gKiBAcmV0dXJucyB7Q3JlYXRlfVxuICogICBDcmVhdGUgYSBwcm9kdWN0aW9uIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHByb2R1Y3Rpb25DcmVhdGUoXywganN4LCBqc3hzKSB7XG4gIHJldHVybiBjcmVhdGVcbiAgLyoqIEB0eXBlIHtDcmVhdGV9ICovXG4gIGZ1bmN0aW9uIGNyZWF0ZShfLCB0eXBlLCBwcm9wcywga2V5KSB7XG4gICAgLy8gT25seSBhbiBhcnJheSB3aGVuIHRoZXJlIGFyZSAyIG9yIG1vcmUgY2hpbGRyZW4uXG4gICAgY29uc3QgaXNTdGF0aWNDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkocHJvcHMuY2hpbGRyZW4pXG4gICAgY29uc3QgZm4gPSBpc1N0YXRpY0NoaWxkcmVuID8ganN4cyA6IGpzeFxuICAgIHJldHVybiBrZXkgPyBmbih0eXBlLCBwcm9wcywga2V5KSA6IGZuKHR5cGUsIHByb3BzKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IGZpbGVQYXRoXG4gKiAgIFBhdGggdG8gZmlsZS5cbiAqIEBwYXJhbSB7SnN4RGV2fSBqc3hERVZcbiAqICAgRGV2ZWxvcG1lbnQuXG4gKiBAcmV0dXJucyB7Q3JlYXRlfVxuICogICBDcmVhdGUgYSBkZXZlbG9wbWVudCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBkZXZlbG9wbWVudENyZWF0ZShmaWxlUGF0aCwganN4REVWKSB7XG4gIHJldHVybiBjcmVhdGVcbiAgLyoqIEB0eXBlIHtDcmVhdGV9ICovXG4gIGZ1bmN0aW9uIGNyZWF0ZShub2RlLCB0eXBlLCBwcm9wcywga2V5KSB7XG4gICAgLy8gT25seSBhbiBhcnJheSB3aGVuIHRoZXJlIGFyZSAyIG9yIG1vcmUgY2hpbGRyZW4uXG4gICAgY29uc3QgaXNTdGF0aWNDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkocHJvcHMuY2hpbGRyZW4pXG4gICAgY29uc3QgcG9pbnQgPSBwb2ludFN0YXJ0KG5vZGUpXG4gICAgcmV0dXJuIGpzeERFVihcbiAgICAgIHR5cGUsXG4gICAgICBwcm9wcyxcbiAgICAgIGtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICB7XG4gICAgICAgIGNvbHVtbk51bWJlcjogcG9pbnQgPyBwb2ludC5jb2x1bW4gLSAxIDogdW5kZWZpbmVkLFxuICAgICAgICBmaWxlTmFtZTogZmlsZVBhdGgsXG4gICAgICAgIGxpbmVOdW1iZXI6IHBvaW50ID8gcG9pbnQubGluZSA6IHVuZGVmaW5lZFxuICAgICAgfSxcbiAgICAgIHVuZGVmaW5lZFxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge1BhcmVudHN9IG5vZGVcbiAqICAgQ3VycmVudCBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5PENoaWxkPn1cbiAqICAgQ2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKSB7XG4gIC8qKiBAdHlwZSB7QXJyYXk8Q2hpbGQ+fSAqL1xuICBjb25zdCBjaGlsZHJlbiA9IFtdXG4gIGxldCBpbmRleCA9IC0xXG4gIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgLy8gTm90ZTogdGVzdCB0aGlzIHdoZW4gU29saWQgZG9lc27igJl0IHdhbnQgdG8gbWVyZ2UgbXkgdXBjb21pbmcgUFIuXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIGNvbnN0IGNvdW50c0J5VGFnTmFtZSA9IHN0YXRlLnBhc3NLZXlzID8gbmV3IE1hcCgpIDogZW1wdHlNYXBcblxuICB3aGlsZSAoKytpbmRleCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2luZGV4XVxuICAgIC8qKiBAdHlwZSB7c3RyaW5nIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBrZXlcblxuICAgIGlmIChzdGF0ZS5wYXNzS2V5cyAmJiBjaGlsZC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGNvbnN0IGNvdW50ID0gY291bnRzQnlUYWdOYW1lLmdldChjaGlsZC50YWdOYW1lKSB8fCAwXG4gICAgICBrZXkgPSBjaGlsZC50YWdOYW1lICsgJy0nICsgY291bnRcbiAgICAgIGNvdW50c0J5VGFnTmFtZS5zZXQoY2hpbGQudGFnTmFtZSwgY291bnQgKyAxKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IG9uZShzdGF0ZSwgY2hpbGQsIGtleSlcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIGNoaWxkcmVuLnB1c2gocmVzdWx0KVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8qKlxuICogSGFuZGxlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHBhcmFtIHtBcnJheTxQYXJlbnRzPn0gYW5jZXN0b3JzXG4gKiAgIFN0YWNrIG9mIHBhcmVudHMuXG4gKiBAcmV0dXJucyB7UHJvcHN9XG4gKiAgIFByb3BzIGZvciBydW50aW1lLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9wZXJ0aWVzKHN0YXRlLCBhbmNlc3RvcnMpIHtcbiAgY29uc3Qgbm9kZSA9IGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoIC0gMV1cbiAgLyoqIEB0eXBlIHtQcm9wc30gKi9cbiAgY29uc3QgcHJvcHMgPSB7fVxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgbGV0IHByb3BcblxuICBpZiAoJ3Byb3BlcnRpZXMnIGluIG5vZGUgJiYgbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGFsaWduVmFsdWVcblxuICAgIGZvciAocHJvcCBpbiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChwcm9wICE9PSAnY2hpbGRyZW4nICYmIG93bi5jYWxsKG5vZGUucHJvcGVydGllcywgcHJvcCkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlUHJvcGVydHkoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYW5jZXN0b3JzLFxuICAgICAgICAgIHByb3AsXG4gICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzW3Byb3BdXG4gICAgICAgIClcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcmVzdWx0XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGF0ZS50YWJsZUNlbGxBbGlnblRvU3R5bGUgJiZcbiAgICAgICAgICAgIGtleSA9PT0gJ2FsaWduJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgdGFibGVDZWxsRWxlbWVudC5oYXMobm9kZS50YWdOYW1lKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgYWxpZ25WYWx1ZSA9IHZhbHVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbGlnblZhbHVlKSB7XG4gICAgICAvLyBBc3N1bWUgc3R5bGUgaXMgYW4gb2JqZWN0LlxuICAgICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge1N0eWxlfSAqLyAocHJvcHMuc3R5bGUgfHwgKHByb3BzLnN0eWxlID0ge30pKVxuICAgICAgc3R5bGVbXG4gICAgICAgIHN0YXRlLnN0eWxlUHJvcGVydHlOYW1lQ2FzZSA9PT0gJ2NzcycgPyAndGV4dC1hbGlnbicgOiAndGV4dEFsaWduJ1xuICAgICAgXSA9IGFsaWduVmFsdWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuLyoqXG4gKiBIYW5kbGUgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge1N0YXRlfSBzdGF0ZVxuICogICBJbmZvIHBhc3NlZCBhcm91bmQuXG4gKiBAcGFyYW0ge0FycmF5PFBhcmVudHM+fSBhbmNlc3RvcnNcbiAqICAgU3RhY2sgb2YgcGFyZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiAgIEtleS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyIHwgc3RyaW5nPiB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSB2YWx1ZVxuICogICBoYXN0IHByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybnMge0ZpZWxkIHwgdW5kZWZpbmVkfVxuICogICBGaWVsZCBmb3IgcnVudGltZSwgb3B0aW9uYWwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5KHN0YXRlLCBhbmNlc3RvcnMsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IGluZm8gPSBmaW5kKHN0YXRlLnNjaGVtYSwgcHJvcClcblxuICAvLyBJZ25vcmUgbnVsbGlzaCBhbmQgYE5hTmAgdmFsdWVzLlxuICBpZiAoXG4gICAgdmFsdWUgPT09IG51bGwgfHxcbiAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzTmFOKHZhbHVlKSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBBY2NlcHQgYGFycmF5YC5cbiAgICAvLyBNb3N0IHByb3BzIGFyZSBzcGFjZS1zZXBhcmF0ZWQuXG4gICAgdmFsdWUgPSBpbmZvLmNvbW1hU2VwYXJhdGVkID8gY29tbWFzKHZhbHVlKSA6IHNwYWNlcyh2YWx1ZSlcbiAgfVxuXG4gIC8vIFJlYWN0IG9ubHkgYWNjZXB0cyBgc3R5bGVgIGFzIG9iamVjdC5cbiAgaWYgKGluZm8ucHJvcGVydHkgPT09ICdzdHlsZScpIHtcbiAgICBsZXQgc3R5bGVPYmplY3QgPVxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogcGFyc2VTdHlsZShzdGF0ZSwgYW5jZXN0b3JzLCBTdHJpbmcodmFsdWUpKVxuXG4gICAgaWYgKHN0YXRlLnN0eWxlUHJvcGVydHlOYW1lQ2FzZSA9PT0gJ2NzcycpIHtcbiAgICAgIHN0eWxlT2JqZWN0ID0gdHJhbnNmb3JtU3R5bGVzVG9Dc3NDYXNpbmcoc3R5bGVPYmplY3QpXG4gICAgfVxuXG4gICAgcmV0dXJuIFsnc3R5bGUnLCBzdHlsZU9iamVjdF1cbiAgfVxuXG4gIHJldHVybiBbXG4gICAgc3RhdGUuZWxlbWVudEF0dHJpYnV0ZU5hbWVDYXNlID09PSAncmVhY3QnICYmIGluZm8uc3BhY2VcbiAgICAgID8gaGFzdFRvUmVhY3RbaW5mby5wcm9wZXJ0eV0gfHwgaW5mby5wcm9wZXJ0eVxuICAgICAgOiBpbmZvLmF0dHJpYnV0ZSxcbiAgICB2YWx1ZVxuICBdXG59XG5cbi8qKlxuICogUGFyc2UgYSBDU1MgZGVjbGFyYXRpb24gdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZXM+fSBhbmNlc3RvcnNcbiAqICAgU3RhY2sgb2Ygbm9kZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqICAgQ1NTIGRlY2xhcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtTdHlsZX1cbiAqICAgUHJvcGVydGllcy5cbiAqIEB0aHJvd3NcbiAqICAgVGhyb3dzIGBWRmlsZU1lc3NhZ2VgIHdoZW4gQ1NTIGNhbm5vdCBiZSBwYXJzZWQuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3RhdGUsIGFuY2VzdG9ycywgdmFsdWUpIHtcbiAgLyoqIEB0eXBlIHtTdHlsZX0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge31cblxuICB0cnkge1xuICAgIHN0eWxlVG9PYmplY3QodmFsdWUsIHJlcGxhY2VyKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICghc3RhdGUuaWdub3JlSW52YWxpZFN0eWxlKSB7XG4gICAgICBjb25zdCBjYXVzZSA9IC8qKiBAdHlwZSB7RXJyb3J9ICovIChlcnJvcilcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVkZpbGVNZXNzYWdlKCdDYW5ub3QgcGFyc2UgYHN0eWxlYCBhdHRyaWJ1dGUnLCB7XG4gICAgICAgIGFuY2VzdG9ycyxcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIHNvdXJjZTogJ2hhc3QtdXRpbC10by1qc3gtcnVudGltZScsXG4gICAgICAgIHJ1bGVJZDogJ3N0eWxlJ1xuICAgICAgfSlcbiAgICAgIG1lc3NhZ2UuZmlsZSA9IHN0YXRlLmZpbGVQYXRoIHx8IHVuZGVmaW5lZFxuICAgICAgbWVzc2FnZS51cmwgPVxuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3N5bnRheC10cmVlL2hhc3QtdXRpbC10by1qc3gtcnVudGltZSNjYW5ub3QtcGFyc2Utc3R5bGUtYXR0cmlidXRlJ1xuXG4gICAgICB0aHJvdyBtZXNzYWdlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxuXG4gIC8qKlxuICAgKiBBZGQgYSBDU1MgcHJvcGVydHkgKG5vcm1hbCwgc28gd2l0aCBkYXNoZXMpIHRvIGByZXN1bHRgIGFzIGEgRE9NIENTU1xuICAgKiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogICBLZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiAgIFZhbHVlXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqICAgTm90aGluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlcGxhY2VyKG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IGtleSA9IG5hbWVcblxuICAgIGlmIChrZXkuc2xpY2UoMCwgMikgIT09ICctLScpIHtcbiAgICAgIGlmIChrZXkuc2xpY2UoMCwgNCkgPT09ICctbXMtJykga2V5ID0gJ21zLScgKyBrZXkuc2xpY2UoNClcbiAgICAgIGtleSA9IGtleS5yZXBsYWNlKGRhc2hTb21ldGhpbmcsIHRvQ2FtZWwpXG4gICAgfVxuXG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgRE9NIGNhc2luZyBzdHlsZSBvYmplY3QgdG8gYSBDU1MgY2FzaW5nIHN0eWxlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge1N0eWxlfSBkb21DYXNpbmdcbiAqIEByZXR1cm5zIHtTdHlsZX1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtU3R5bGVzVG9Dc3NDYXNpbmcoZG9tQ2FzaW5nKSB7XG4gIC8qKiBAdHlwZSB7U3R5bGV9ICovXG4gIGNvbnN0IGNzc0Nhc2luZyA9IHt9XG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBsZXQgZnJvbVxuXG4gIGZvciAoZnJvbSBpbiBkb21DYXNpbmcpIHtcbiAgICBpZiAob3duLmNhbGwoZG9tQ2FzaW5nLCBmcm9tKSkge1xuICAgICAgY3NzQ2FzaW5nW3RyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmcoZnJvbSldID0gZG9tQ2FzaW5nW2Zyb21dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNzc0Nhc2luZ1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIERPTSBjYXNpbmcgc3R5bGUgZmllbGQgdG8gYSBDU1MgY2FzaW5nIHN0eWxlIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdHlsZVRvQ3NzQ2FzaW5nKGZyb20pIHtcbiAgbGV0IHRvID0gZnJvbS5yZXBsYWNlKGNhcCwgdG9EYXNoKVxuICAvLyBIYW5kbGUgYG1zLXh4eGAgLT4gYC1tcy14eHhgLlxuICBpZiAodG8uc2xpY2UoMCwgMykgPT09ICdtcy0nKSB0byA9ICctJyArIHRvXG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1ha2UgYCQxYCBjYXBpdGFsaXplZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gX1xuICogICBXaGF0ZXZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSAkMVxuICogICBTaW5nbGUgQVNDSUkgYWxwaGFiZXRpY2FsLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqICAgQ2FwaXRhbGl6ZWQgYCQxYC5cbiAqL1xuZnVuY3Rpb24gdG9DYW1lbChfLCAkMSkge1xuICByZXR1cm4gJDEudG9VcHBlckNhc2UoKVxufVxuXG4vKipcbiAqIE1ha2UgYCQwYCBkYXNoIGNhc2VkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMFxuICogICBDYXBpdGFsaXplZCBBU0NJSSBsZXRlci5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiAgIERhc2ggYW5kIGxvd2VyIGxldHRlci5cbiAqL1xuZnVuY3Rpb24gdG9EYXNoKCQwKSB7XG4gIHJldHVybiAnLScgKyAkMC50b0xvd2VyQ2FzZSgpXG59XG4iXSwibmFtZXMiOlsic3RyaW5naWZ5IiwiY29tbWFzIiwid2hpdGVzcGFjZSIsImZpbmQiLCJoYXN0VG9SZWFjdCIsImh0bWwiLCJzdmciLCJzcGFjZXMiLCJzdHlsZVRvT2JqZWN0IiwicG9pbnRTdGFydCIsIlZGaWxlTWVzc2FnZSIsIm93biIsImhhc093blByb3BlcnR5IiwiZW1wdHlNYXAiLCJNYXAiLCJjYXAiLCJkYXNoU29tZXRoaW5nIiwidGFibGVFbGVtZW50cyIsIlNldCIsInRhYmxlQ2VsbEVsZW1lbnQiLCJ0b0pzeFJ1bnRpbWUiLCJ0cmVlIiwib3B0aW9ucyIsIkZyYWdtZW50IiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwiZmlsZVBhdGgiLCJjcmVhdGUiLCJkZXZlbG9wbWVudCIsImpzeERFViIsImRldmVsb3BtZW50Q3JlYXRlIiwianN4IiwianN4cyIsInByb2R1Y3Rpb25DcmVhdGUiLCJzdGF0ZSIsImFuY2VzdG9ycyIsImNvbXBvbmVudHMiLCJlbGVtZW50QXR0cmlidXRlTmFtZUNhc2UiLCJpZ25vcmVJbnZhbGlkU3R5bGUiLCJwYXNzS2V5cyIsInBhc3NOb2RlIiwic2NoZW1hIiwic3BhY2UiLCJzdHlsZVByb3BlcnR5TmFtZUNhc2UiLCJ0YWJsZUNlbGxBbGlnblRvU3R5bGUiLCJyZXN1bHQiLCJvbmUiLCJjaGlsZHJlbiIsIm5vZGUiLCJrZXkiLCJ0eXBlIiwicGFyZW50U2NoZW1hIiwidGFnTmFtZSIsInRvTG93ZXJDYXNlIiwicHVzaCIsImNyZWF0ZUNoaWxkcmVuIiwicHJvcHMiLCJjcmVhdGVQcm9wZXJ0aWVzIiwicG9wIiwiaGFzIiwiZmlsdGVyIiwiY2hpbGQiLCJjYWxsIiwibGVuZ3RoIiwidmFsdWUiLCJfIiwiaXNTdGF0aWNDaGlsZHJlbiIsIkFycmF5IiwiaXNBcnJheSIsImZuIiwicG9pbnQiLCJjb2x1bW5OdW1iZXIiLCJjb2x1bW4iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJsaW5lIiwiaW5kZXgiLCJjb3VudHNCeVRhZ05hbWUiLCJjb3VudCIsImdldCIsInNldCIsInByb3AiLCJwcm9wZXJ0aWVzIiwiYWxpZ25WYWx1ZSIsImNyZWF0ZVByb3BlcnR5Iiwic3R5bGUiLCJpbmZvIiwiTnVtYmVyIiwiaXNOYU4iLCJjb21tYVNlcGFyYXRlZCIsInByb3BlcnR5Iiwic3R5bGVPYmplY3QiLCJwYXJzZVN0eWxlIiwiU3RyaW5nIiwidHJhbnNmb3JtU3R5bGVzVG9Dc3NDYXNpbmciLCJhdHRyaWJ1dGUiLCJyZXBsYWNlciIsImVycm9yIiwiY2F1c2UiLCJtZXNzYWdlIiwic291cmNlIiwicnVsZUlkIiwiZmlsZSIsInVybCIsIm5hbWUiLCJzbGljZSIsInJlcGxhY2UiLCJ0b0NhbWVsIiwiZG9tQ2FzaW5nIiwiY3NzQ2FzaW5nIiwiZnJvbSIsInRyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmciLCJ0byIsInRvRGFzaCIsIiQxIiwidG9VcHBlckNhc2UiLCIkMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-to-jsx-runtime/lib/index.js\n");

/***/ })

};
;